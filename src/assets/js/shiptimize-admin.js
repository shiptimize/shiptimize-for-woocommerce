/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/shiptimize-for-woocommerce/assets/js";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./shiptimize-admin.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/shiptimize-utils.js":
/*!********************************!*\
  !*** ./js/shiptimize-utils.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** \n * Singleton object we can use for platform independent stuff \n */\nvar ShiptimizeUtils = function () {\n  function ShiptimizeUtils() {\n    _classCallCheck(this, ShiptimizeUtils);\n  }\n\n  /** \n   * Inject Script into the page \n   * @param string src \n   */\n\n\n  _createClass(ShiptimizeUtils, [{\n    key: \"injectExternalScript\",\n    value: function injectExternalScript(src) {\n      var s = document.createElement(\"script\");\n      s.setAttribute(\"src\", src);\n      document.body.appendChild(s);\n    }\n\n    /** \n     * Inject a script string \n     */\n\n  }, {\n    key: \"injectScript\",\n    value: function injectScript(contents) {\n      var e = document.createElement(\"script\");\n      e.value = contents;\n      document.body.appendChild(e);\n    }\n\n    /** \n     * Removes all not numeric chars from the string \n     *\n     * @param string string - the input string \n     * @return the string without chars that are not numbers \n     */\n\n  }, {\n    key: \"removeNonNumeric\",\n    value: function removeNonNumeric(string) {\n      return string.replace(/\\D/g, '');\n    }\n\n    /** \n     * Check if the given url exists and is valid\n     * We use this to check if the carrier icon exists given \n     * a url path and the naming convention {carrier_id}.svg \n     * Make sure the correct protocol is appended to the url http != https \n     * \n     * @return true it the url exists and is valid \n     */\n\n  }, {\n    key: \"isUrlValid\",\n    value: function isUrlValid(url) {\n      var http = new XMLHttpRequest();\n      http.open('HEAD', url, false);\n      http.send();\n      return http.status == 200;\n    }\n\n    /** \n     * Open a new window with the provided URL \n     * @string url \n     * @return bool if the window was opened, false if popup blocker enabled \n     */\n\n  }, {\n    key: \"openNewWindow\",\n    value: function openNewWindow(url, options) {\n      var newWin = window.open(url, '_blank', options);\n      var blocked = !newWin || newWin.closed || typeof newWin.closed == 'undefined';\n\n      return !blocked;\n    }\n  }]);\n\n  return ShiptimizeUtils;\n}();\n\nvar utils = new ShiptimizeUtils();\nexports.default = utils;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9zaGlwdGltaXplLXV0aWxzLmpzPzAwZDQiXSwibmFtZXMiOlsiU2hpcHRpbWl6ZVV0aWxzIiwic3JjIiwicyIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnRzIiwiZSIsInZhbHVlIiwic3RyaW5nIiwicmVwbGFjZSIsInVybCIsImh0dHAiLCJYTUxIdHRwUmVxdWVzdCIsIm9wZW4iLCJzZW5kIiwic3RhdHVzIiwib3B0aW9ucyIsIm5ld1dpbiIsIndpbmRvdyIsImJsb2NrZWQiLCJjbG9zZWQiLCJ1dGlscyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBOzs7SUFHTUEsZTtBQUVGLDZCQUFjO0FBQUE7QUFFYjs7QUFHRDs7Ozs7Ozs7eUNBSXFCQyxHLEVBQUs7QUFDdEIsVUFBSUMsSUFBSUMsU0FBU0MsYUFBVCxDQUF1QixRQUF2QixDQUFSO0FBQ0FGLFFBQUVHLFlBQUYsQ0FBZSxLQUFmLEVBQXNCSixHQUF0QjtBQUNBRSxlQUFTRyxJQUFULENBQWNDLFdBQWQsQ0FBMEJMLENBQTFCO0FBQ0g7O0FBR0Q7Ozs7OztpQ0FHYU0sUSxFQUFVO0FBQ25CLFVBQUlDLElBQUlOLFNBQVNDLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBUjtBQUNBSyxRQUFFQyxLQUFGLEdBQVVGLFFBQVY7QUFDQUwsZUFBU0csSUFBVCxDQUFjQyxXQUFkLENBQTBCRSxDQUExQjtBQUNIOztBQUVEOzs7Ozs7Ozs7cUNBTWlCRSxNLEVBQVE7QUFDckIsYUFBT0EsT0FBT0MsT0FBUCxDQUFlLEtBQWYsRUFBc0IsRUFBdEIsQ0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7OzsrQkFRV0MsRyxFQUFLO0FBQ1osVUFBSUMsT0FBTyxJQUFJQyxjQUFKLEVBQVg7QUFDQUQsV0FBS0UsSUFBTCxDQUFVLE1BQVYsRUFBa0JILEdBQWxCLEVBQXVCLEtBQXZCO0FBQ0FDLFdBQUtHLElBQUw7QUFDQSxhQUFPSCxLQUFLSSxNQUFMLElBQWUsR0FBdEI7QUFDSDs7QUFFRDs7Ozs7Ozs7a0NBS2NMLEcsRUFBS00sTyxFQUFRO0FBQ3ZCLFVBQUlDLFNBQVNDLE9BQU9MLElBQVAsQ0FBWUgsR0FBWixFQUFpQixRQUFqQixFQUEyQk0sT0FBM0IsQ0FBYjtBQUNBLFVBQUlHLFVBQVUsQ0FBQ0YsTUFBRCxJQUFXQSxPQUFPRyxNQUFsQixJQUE0QixPQUFPSCxPQUFPRyxNQUFkLElBQXNCLFdBQWhFOztBQUVBLGFBQU8sQ0FBQ0QsT0FBUjtBQUNIOzs7Ozs7QUFJTCxJQUFJRSxRQUFRLElBQUl4QixlQUFKLEVBQVo7a0JBQ2V3QixLIiwiZmlsZSI6Ii4vanMvc2hpcHRpbWl6ZS11dGlscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBcbiAqIFNpbmdsZXRvbiBvYmplY3Qgd2UgY2FuIHVzZSBmb3IgcGxhdGZvcm0gaW5kZXBlbmRlbnQgc3R1ZmYgXG4gKi9cbmNsYXNzIFNoaXB0aW1pemVVdGlscyB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcblxuICAgIH1cblxuXG4gICAgLyoqIFxuICAgICAqIEluamVjdCBTY3JpcHQgaW50byB0aGUgcGFnZSBcbiAgICAgKiBAcGFyYW0gc3RyaW5nIHNyYyBcbiAgICAgKi9cbiAgICBpbmplY3RFeHRlcm5hbFNjcmlwdChzcmMpIHtcbiAgICAgICAgbGV0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICBzLnNldEF0dHJpYnV0ZShcInNyY1wiLCBzcmMpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHMpO1xuICAgIH1cblxuXG4gICAgLyoqIFxuICAgICAqIEluamVjdCBhIHNjcmlwdCBzdHJpbmcgXG4gICAgICovXG4gICAgaW5qZWN0U2NyaXB0KGNvbnRlbnRzKSB7XG4gICAgICAgIGxldCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgZS52YWx1ZSA9IGNvbnRlbnRzO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGUpO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiBSZW1vdmVzIGFsbCBub3QgbnVtZXJpYyBjaGFycyBmcm9tIHRoZSBzdHJpbmcgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RyaW5nIHN0cmluZyAtIHRoZSBpbnB1dCBzdHJpbmcgXG4gICAgICogQHJldHVybiB0aGUgc3RyaW5nIHdpdGhvdXQgY2hhcnMgdGhhdCBhcmUgbm90IG51bWJlcnMgXG4gICAgICovXG4gICAgcmVtb3ZlTm9uTnVtZXJpYyhzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9cXEQvZywgJycpO1xuICAgIH1cblxuICAgIC8qKiBcbiAgICAgKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdXJsIGV4aXN0cyBhbmQgaXMgdmFsaWRcbiAgICAgKiBXZSB1c2UgdGhpcyB0byBjaGVjayBpZiB0aGUgY2FycmllciBpY29uIGV4aXN0cyBnaXZlbiBcbiAgICAgKiBhIHVybCBwYXRoIGFuZCB0aGUgbmFtaW5nIGNvbnZlbnRpb24ge2NhcnJpZXJfaWR9LnN2ZyBcbiAgICAgKiBNYWtlIHN1cmUgdGhlIGNvcnJlY3QgcHJvdG9jb2wgaXMgYXBwZW5kZWQgdG8gdGhlIHVybCBodHRwICE9IGh0dHBzIFxuICAgICAqIFxuICAgICAqIEByZXR1cm4gdHJ1ZSBpdCB0aGUgdXJsIGV4aXN0cyBhbmQgaXMgdmFsaWQgXG4gICAgICovIFxuICAgIGlzVXJsVmFsaWQodXJsKSB7XG4gICAgICAgIHZhciBodHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIGh0dHAub3BlbignSEVBRCcsIHVybCwgZmFsc2UpO1xuICAgICAgICBodHRwLnNlbmQoKTtcbiAgICAgICAgcmV0dXJuIGh0dHAuc3RhdHVzID09IDIwMDtcbiAgICB9XG5cbiAgICAvKiogXG4gICAgICogT3BlbiBhIG5ldyB3aW5kb3cgd2l0aCB0aGUgcHJvdmlkZWQgVVJMIFxuICAgICAqIEBzdHJpbmcgdXJsIFxuICAgICAqIEByZXR1cm4gYm9vbCBpZiB0aGUgd2luZG93IHdhcyBvcGVuZWQsIGZhbHNlIGlmIHBvcHVwIGJsb2NrZXIgZW5hYmxlZCBcbiAgICAgKi8gIFxuICAgIG9wZW5OZXdXaW5kb3codXJsLCBvcHRpb25zKXtcbiAgICAgICAgbGV0IG5ld1dpbiA9IHdpbmRvdy5vcGVuKHVybCwgJ19ibGFuaycsIG9wdGlvbnMpOyBcbiAgICAgICAgbGV0IGJsb2NrZWQgPSAhbmV3V2luIHx8IG5ld1dpbi5jbG9zZWQgfHwgdHlwZW9mIG5ld1dpbi5jbG9zZWQ9PSd1bmRlZmluZWQnOyBcblxuICAgICAgICByZXR1cm4gIWJsb2NrZWQ7IFxuICAgIH1cbn1cblxuXG5sZXQgdXRpbHMgPSBuZXcgU2hpcHRpbWl6ZVV0aWxzKCk7XG5leHBvcnQgZGVmYXVsdCB1dGlsczsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/shiptimize-utils.js\n");

/***/ }),

/***/ "./js/shiptimize-weight-based-shipping.js":
/*!************************************************!*\
  !*** ./js/shiptimize-weight-based-shipping.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** \n * plug into the  dom and  append shiptimize settings\n * Save on change via ajax \n * We can't save rule by rule withough pluggin into the checkout \n * Currently only the instance id is saved \n */\nvar ShiptimizeWeightBasedShipping = function () {\n  function ShiptimizeWeightBasedShipping() {\n    _classCallCheck(this, ShiptimizeWeightBasedShipping);\n\n    console.log(\"Shiptimize options for WeightBasedShipping\");\n    this.init();\n  }\n\n  _createClass(ShiptimizeWeightBasedShipping, [{\n    key: \"init\",\n    value: function init() {\n      //not a shipping method page \n      if (typeof shiptimize_carrier == 'undefined') {\n        return;\n      }\n\n      var regexInstance = /instance_id=([0-9]*)/.exec(window.location.search);\n\n      if (!regexInstance) {\n        console.log(\"invalid url params cannot find instance_id \" + window.location.search);\n        return;\n      }\n\n      this.instance_id = regexInstance[1];\n      this.attachShiptimizeOptions();\n    }\n\n    /** \n     * Save our options for this instance \n     */\n\n  }, {\n    key: \"saveOptions\",\n    value: function saveOptions(elem) {\n      var data = {\n        'data': this.eForm.serializeArray(),\n        'instance_id': this.instance_id,\n        'action': 'shiptimize_wbs_settings'\n      };\n\n      jQuery.post(ajaxurl, data, function (resp) {\n        console.log(\"response \", resp);\n      });\n\n      console.log(this.eForm, \"Saveoptions \", data);\n\n      jQuery(\".shiptimize-optionvalues\").hide();\n      var extraOption = jQuery(\".shiptimize-extraoptions\").val();\n      jQuery(\"#shiptimize-extraoptions\" + extraOption).show();\n    }\n\n    /** \n     * Attach the shiptimize options under the title   \n     */\n\n  }, {\n    key: \"attachShiptimizeOptions\",\n    value: function attachShiptimizeOptions() {\n\n      var eShiptimizeOptions = jQuery(\"<form id='shiptimizeoptions' class=\\\"wbs-shiptimizeoptions\\\"></form>\");\n      var oHtml = '';\n\n      //no options , nothing to do \n      if (typeof shiptimize_carrier.OptionList == 'undefined') {\n        return;\n      }\n\n      //shiptimize_extraoptions\n      //shiptimize_checkboxes\n      //Add a Save button \n      var htmlServiceLevels = '';\n      var htmlExtraOptions = '';\n      var htmlCheckboxes = '';\n      var htmlExtravalues = '';\n      for (var x = 0; x < shiptimize_carrier.OptionList.length; ++x) {\n        var option = shiptimize_carrier.OptionList[x];\n\n        if (option.Type == 1) {\n          if (typeof option.OptionValues != 'undefined') {\n            for (var i = 0; i < option.OptionValues.length; ++i) {\n              var optionChild = option.OptionValues[i];\n              var selected = shiptimize_options['service_level'] == optionChild.Id ? 'selected' : '';\n              htmlServiceLevels += \"<option value='\" + optionChild.Id + \"' \" + selected + \">\" + optionChild.Name + \"</option>\";\n            }\n          }\n        } else if (shiptimize_extraoptions.includes(option.Id + \"\")) {\n          var _selected = shiptimize_options['extraoptions'] == option.Id ? 'selected' : '';\n          htmlExtraOptions += \"<option value='\" + option.Id + \"' \" + _selected + \">\" + option.Name + \"</option>\";\n          if (option.OptionFields && option.OptionFields.length > 0) {\n            for (var j = 0; j < option.OptionFields.length; ++j) {\n              if (option.OptionFields[j].OptionValues) {\n                var optionField = option.OptionFields[j];\n                htmlExtravalues += '<select class=\"shiptimize-optionvalues\" id=\"shiptimize-extraoptions' + option.Id + '\" name=\"extraoptions' + option.Id + '\" onchange=\\\"shiptimize.platform.wbs.saveOptions(jQuery(this))\\\">';\n                for (var i = 0; i < optionField.OptionValues.length; ++i) {\n                  var _optionChild = optionField.OptionValues[i];\n                  var _selected2 = shiptimize_options['extraoptionvalue' + option.Id] == _optionChild.Id ? 'selected' : '';\n                  htmlExtravalues += \"<option value='\" + _optionChild.Id + \"' \" + _selected2 + \">\" + _optionChild.Name + \"</option>\";\n                }\n                htmlExtravalues += '</select>';\n              }\n            }\n          }\n        } else {\n          var keys = Object.keys(shiptimize_checkboxes);\n          for (var i = 0; i < keys.length; ++i) {\n            if (option.Id == keys[i]) {\n              var optionName = shiptimize_checkboxes[option.Id];\n              var checked = shiptimize_options[optionName] == option.Id ? 'checked' : '';\n              htmlCheckboxes += '<span class=\"wbs-shiptimize-option\"><input ' + checked + ' class=\"wbs-rse-checkbox\"  onchange=\"shiptimize.platform.wbs.saveOptions(jQuery(this))\" type=\"checkbox\" name=\"' + optionName + '\" value=\"' + option.Id + '\"/>' + shiptimize_checkboxes[option.Id] + \"</span>\";\n            }\n          }\n        }\n      }\n\n      if (htmlServiceLevels.length > 0) {\n        oHtml += \"<span class=\\\"wbs-shiptimize-option\\\"><label>\" + shiptimize_labels.servicelevel + \"</label> <select name=\\\"service_level\\\"  onchange=\\\"shiptimize.platform.wbs.saveOptions(jQuery(this))\\\"><option>-</option>\" + htmlServiceLevels + \"</select></span>\";\n      }\n\n      if (htmlExtraOptions.length > 0) {\n        oHtml += \"<span class=\\\"wbs-shiptimize-option\\\"><label>\" + shiptimize_labels.extraoptions + \"</label> <select class='shiptimize-extraoptions' name=\\\"extraoptions\\\"  onchange=\\\"shiptimize.platform.wbs.saveOptions(jQuery(this))\\\"><option>-</option>\" + htmlExtraOptions + \"</select> \" + htmlExtravalues + \" </span>\";\n      }\n\n      oHtml += htmlCheckboxes;\n\n      //Pickup Behaviour?\n      if (shiptimize_carrier.HasPickup) {\n        var selecthtml = '<select class=\"shiptimize-extraoptions\" name=\"pickupbehaviour\" onchange=\\\"shiptimize.platform.wbs.saveOptions(jQuery(this))\\\">';\n        for (var x = 0; x < 3; ++x) {\n          var _selected3 = shiptimize_options['pickupbehaviour'] == x ? 'selected' : '';\n          selecthtml += \"<option value=\\\"\" + x + \"\\\" \" + _selected3 + \">\" + shiptimize_labels['pickup' + x] + \"</option>\";\n        }\n        selecthtml += '</select>';\n\n        oHtml += \"<span class=\\\"wbs-shiptimize-option\\\"><label>\" + shiptimize_labels.pickupbehaviour + \"</label> \" + selecthtml + \"</span>\";\n      }\n\n      if (oHtml.length > 0) {\n        eShiptimizeOptions.html(\"<h3>Shiptimize Settings</h3>\" + oHtml);\n        eShiptimizeOptions.insertAfter(jQuery(\"#mainform\"));\n        this.eForm = jQuery(\"#shiptimizeoptions\");\n        this.saveOptions(jQuery(\".shiptimize-extraoptions\"));\n      }\n    }\n  }]);\n\n  return ShiptimizeWeightBasedShipping;\n}();\n\nexports.default = ShiptimizeWeightBasedShipping;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9zaGlwdGltaXplLXdlaWdodC1iYXNlZC1zaGlwcGluZy5qcz8yZThjIl0sIm5hbWVzIjpbIlNoaXB0aW1pemVXZWlnaHRCYXNlZFNoaXBwaW5nIiwiY29uc29sZSIsImxvZyIsImluaXQiLCJzaGlwdGltaXplX2NhcnJpZXIiLCJyZWdleEluc3RhbmNlIiwiZXhlYyIsIndpbmRvdyIsImxvY2F0aW9uIiwic2VhcmNoIiwiaW5zdGFuY2VfaWQiLCJhdHRhY2hTaGlwdGltaXplT3B0aW9ucyIsImVsZW0iLCJkYXRhIiwiZUZvcm0iLCJzZXJpYWxpemVBcnJheSIsImpRdWVyeSIsInBvc3QiLCJhamF4dXJsIiwicmVzcCIsImhpZGUiLCJleHRyYU9wdGlvbiIsInZhbCIsInNob3ciLCJlU2hpcHRpbWl6ZU9wdGlvbnMiLCJvSHRtbCIsIk9wdGlvbkxpc3QiLCJodG1sU2VydmljZUxldmVscyIsImh0bWxFeHRyYU9wdGlvbnMiLCJodG1sQ2hlY2tib3hlcyIsImh0bWxFeHRyYXZhbHVlcyIsIngiLCJsZW5ndGgiLCJvcHRpb24iLCJUeXBlIiwiT3B0aW9uVmFsdWVzIiwiaSIsIm9wdGlvbkNoaWxkIiwic2VsZWN0ZWQiLCJzaGlwdGltaXplX29wdGlvbnMiLCJJZCIsIk5hbWUiLCJzaGlwdGltaXplX2V4dHJhb3B0aW9ucyIsImluY2x1ZGVzIiwiT3B0aW9uRmllbGRzIiwiaiIsIm9wdGlvbkZpZWxkIiwia2V5cyIsIk9iamVjdCIsInNoaXB0aW1pemVfY2hlY2tib3hlcyIsIm9wdGlvbk5hbWUiLCJjaGVja2VkIiwic2hpcHRpbWl6ZV9sYWJlbHMiLCJzZXJ2aWNlbGV2ZWwiLCJleHRyYW9wdGlvbnMiLCJIYXNQaWNrdXAiLCJzZWxlY3RodG1sIiwicGlja3VwYmVoYXZpb3VyIiwiaHRtbCIsImluc2VydEFmdGVyIiwic2F2ZU9wdGlvbnMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0lBTXFCQSw2QjtBQUVuQiwyQ0FBYztBQUFBOztBQUNaQyxZQUFRQyxHQUFSLENBQVksNENBQVo7QUFDQSxTQUFLQyxJQUFMO0FBRUQ7Ozs7MkJBRU07QUFDTDtBQUNBLFVBQUksT0FBUUMsa0JBQVIsSUFBK0IsV0FBbkMsRUFBZ0Q7QUFDOUM7QUFDRDs7QUFFRCxVQUFNQyxnQkFBZ0IsdUJBQXVCQyxJQUF2QixDQUE0QkMsT0FBT0MsUUFBUCxDQUFnQkMsTUFBNUMsQ0FBdEI7O0FBRUEsVUFBSSxDQUFDSixhQUFMLEVBQW9CO0FBQ2xCSixnQkFBUUMsR0FBUixDQUFZLGdEQUFnREssT0FBT0MsUUFBUCxDQUFnQkMsTUFBNUU7QUFDQTtBQUNEOztBQUVELFdBQUtDLFdBQUwsR0FBbUJMLGNBQWMsQ0FBZCxDQUFuQjtBQUNBLFdBQUtNLHVCQUFMO0FBQ0Q7O0FBRUQ7Ozs7OztnQ0FHWUMsSSxFQUFNO0FBQ2hCLFVBQUlDLE9BQU87QUFDVCxnQkFBUSxLQUFLQyxLQUFMLENBQVdDLGNBQVgsRUFEQztBQUVULHVCQUFlLEtBQUtMLFdBRlg7QUFHVCxrQkFBVTtBQUhELE9BQVg7O0FBTUFNLGFBQU9DLElBQVAsQ0FBWUMsT0FBWixFQUFxQkwsSUFBckIsRUFBMkIsVUFBVU0sSUFBVixFQUFnQjtBQUN6Q2xCLGdCQUFRQyxHQUFSLENBQVksV0FBWixFQUF5QmlCLElBQXpCO0FBQ0QsT0FGRDs7QUFJQWxCLGNBQVFDLEdBQVIsQ0FBWSxLQUFLWSxLQUFqQixFQUF3QixjQUF4QixFQUF3Q0QsSUFBeEM7O0FBRUFHLGFBQU8sMEJBQVAsRUFBbUNJLElBQW5DO0FBQ0EsVUFBSUMsY0FBY0wsT0FBTywwQkFBUCxFQUFtQ00sR0FBbkMsRUFBbEI7QUFDQU4sYUFBTyw2QkFBMkJLLFdBQWxDLEVBQStDRSxJQUEvQztBQUVEOztBQUVEOzs7Ozs7OENBRzBCOztBQUV4QixVQUFJQyxxQkFBcUJSLE9BQU8sc0VBQVAsQ0FBekI7QUFDQSxVQUFJUyxRQUFRLEVBQVo7O0FBRUE7QUFDQSxVQUFJLE9BQVFyQixtQkFBbUJzQixVQUEzQixJQUEwQyxXQUE5QyxFQUEyRDtBQUN6RDtBQUNEOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFVBQUlDLG9CQUFvQixFQUF4QjtBQUNBLFVBQUlDLG1CQUFtQixFQUF2QjtBQUNBLFVBQUlDLGlCQUFpQixFQUFyQjtBQUNBLFVBQUlDLGtCQUFrQixFQUF0QjtBQUNBLFdBQUssSUFBSUMsSUFBSSxDQUFiLEVBQWdCQSxJQUFJM0IsbUJBQW1Cc0IsVUFBbkIsQ0FBOEJNLE1BQWxELEVBQTBELEVBQUVELENBQTVELEVBQStEO0FBQzdELFlBQU1FLFNBQVM3QixtQkFBbUJzQixVQUFuQixDQUE4QkssQ0FBOUIsQ0FBZjs7QUFFQSxZQUFJRSxPQUFPQyxJQUFQLElBQWUsQ0FBbkIsRUFBc0I7QUFDcEIsY0FBSSxPQUFRRCxPQUFPRSxZQUFmLElBQWdDLFdBQXBDLEVBQWlEO0FBQy9DLGlCQUFLLElBQUlDLElBQUksQ0FBYixFQUFnQkEsSUFBSUgsT0FBT0UsWUFBUCxDQUFvQkgsTUFBeEMsRUFBZ0QsRUFBRUksQ0FBbEQsRUFBcUQ7QUFDbkQsa0JBQUlDLGNBQWNKLE9BQU9FLFlBQVAsQ0FBb0JDLENBQXBCLENBQWxCO0FBQ0Esa0JBQUlFLFdBQVdDLG1CQUFtQixlQUFuQixLQUF1Q0YsWUFBWUcsRUFBbkQsR0FBd0QsVUFBeEQsR0FBcUUsRUFBcEY7QUFDQWIsbUNBQXFCLG9CQUFvQlUsWUFBWUcsRUFBaEMsR0FBcUMsSUFBckMsR0FBNENGLFFBQTVDLEdBQXVELEdBQXZELEdBQTZERCxZQUFZSSxJQUF6RSxHQUFnRixXQUFyRztBQUNEO0FBQ0Y7QUFDRixTQVJELE1BUU8sSUFBSUMsd0JBQXdCQyxRQUF4QixDQUFpQ1YsT0FBT08sRUFBUCxHQUFVLEVBQTNDLENBQUosRUFBb0Q7QUFDekQsY0FBSUYsWUFBV0MsbUJBQW1CLGNBQW5CLEtBQXNDTixPQUFPTyxFQUE3QyxHQUFrRCxVQUFsRCxHQUErRCxFQUE5RTtBQUNBWiw4QkFBb0Isb0JBQW9CSyxPQUFPTyxFQUEzQixHQUFnQyxJQUFoQyxHQUF1Q0YsU0FBdkMsR0FBa0QsR0FBbEQsR0FBd0RMLE9BQU9RLElBQS9ELEdBQXNFLFdBQTFGO0FBQ0EsY0FBSVIsT0FBT1csWUFBUCxJQUF1QlgsT0FBT1csWUFBUCxDQUFvQlosTUFBcEIsR0FBMkIsQ0FBdEQsRUFBeUQ7QUFDdkQsaUJBQU0sSUFBSWEsSUFBRSxDQUFaLEVBQWVBLElBQUVaLE9BQU9XLFlBQVAsQ0FBb0JaLE1BQXJDLEVBQTZDLEVBQUVhLENBQS9DLEVBQWtEO0FBQ2hELGtCQUFJWixPQUFPVyxZQUFQLENBQW9CQyxDQUFwQixFQUF1QlYsWUFBM0IsRUFBeUM7QUFDdkMsb0JBQUlXLGNBQWNiLE9BQU9XLFlBQVAsQ0FBb0JDLENBQXBCLENBQWxCO0FBQ0FmLG1DQUFtQix3RUFBd0VHLE9BQU9PLEVBQS9FLEdBQW9GLHNCQUFwRixHQUE2R1AsT0FBT08sRUFBcEgsR0FBeUgsbUVBQTVJO0FBQ0EscUJBQUssSUFBSUosSUFBSSxDQUFiLEVBQWdCQSxJQUFJVSxZQUFZWCxZQUFaLENBQXlCSCxNQUE3QyxFQUFxRCxFQUFFSSxDQUF2RCxFQUEwRDtBQUN4RCxzQkFBSUMsZUFBY1MsWUFBWVgsWUFBWixDQUF5QkMsQ0FBekIsQ0FBbEI7QUFDQSxzQkFBSUUsYUFBV0MsbUJBQW1CLHFCQUFxQk4sT0FBT08sRUFBL0MsS0FBc0RILGFBQVlHLEVBQWxFLEdBQXVFLFVBQXZFLEdBQW9GLEVBQW5HO0FBQ0FWLHFDQUFtQixvQkFBb0JPLGFBQVlHLEVBQWhDLEdBQXFDLElBQXJDLEdBQTRDRixVQUE1QyxHQUF1RCxHQUF2RCxHQUE2REQsYUFBWUksSUFBekUsR0FBZ0YsV0FBbkc7QUFDRDtBQUNEWCxtQ0FBbUIsV0FBbkI7QUFDRDtBQUNGO0FBQ0Y7QUFDRixTQWpCTSxNQWlCQTtBQUNMLGNBQU1pQixPQUFPQyxPQUFPRCxJQUFQLENBQVlFLHFCQUFaLENBQWI7QUFDQSxlQUFLLElBQUliLElBQUksQ0FBYixFQUFnQkEsSUFBSVcsS0FBS2YsTUFBekIsRUFBaUMsRUFBRUksQ0FBbkMsRUFBc0M7QUFDcEMsZ0JBQUlILE9BQU9PLEVBQVAsSUFBYU8sS0FBS1gsQ0FBTCxDQUFqQixFQUEwQjtBQUN4QixrQkFBSWMsYUFBYUQsc0JBQXNCaEIsT0FBT08sRUFBN0IsQ0FBakI7QUFDQSxrQkFBSVcsVUFBVVosbUJBQW1CVyxVQUFuQixLQUFrQ2pCLE9BQU9PLEVBQXpDLEdBQThDLFNBQTlDLEdBQTBELEVBQXhFO0FBQ0FYLGdDQUFrQixnREFBZ0RzQixPQUFoRCxHQUEwRCxnSEFBMUQsR0FBNktELFVBQTdLLEdBQTBMLFdBQTFMLEdBQXdNakIsT0FBT08sRUFBL00sR0FBb04sS0FBcE4sR0FBNE5TLHNCQUFzQmhCLE9BQU9PLEVBQTdCLENBQTVOLEdBQStQLFNBQWpSO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsVUFBSWIsa0JBQWtCSyxNQUFsQixHQUEyQixDQUEvQixFQUFrQztBQUNoQ1AsaUJBQVMsa0RBQWtEMkIsa0JBQWtCQyxZQUFwRSxHQUFtRiw0SEFBbkYsR0FBa04xQixpQkFBbE4sR0FBc08sa0JBQS9PO0FBQ0Q7O0FBRUQsVUFBSUMsaUJBQWlCSSxNQUFqQixHQUEwQixDQUE5QixFQUFpQztBQUMvQlAsaUJBQVMsa0RBQWtEMkIsa0JBQWtCRSxZQUFwRSxHQUFtRiwySkFBbkYsR0FBaVAxQixnQkFBalAsR0FBb1EsWUFBcFEsR0FBbVJFLGVBQW5SLEdBQW9TLFVBQTdTO0FBQ0Q7O0FBRURMLGVBQVNJLGNBQVQ7O0FBRUE7QUFDQSxVQUFHekIsbUJBQW1CbUQsU0FBdEIsRUFBaUM7QUFDL0IsWUFBSUMsYUFBYSxnSUFBakI7QUFDQSxhQUFLLElBQUl6QixJQUFFLENBQVgsRUFBY0EsSUFBSSxDQUFsQixFQUFxQixFQUFFQSxDQUF2QixFQUEwQjtBQUN4QixjQUFJTyxhQUFXQyxtQkFBbUIsaUJBQW5CLEtBQXlDUixDQUF6QyxHQUE2QyxVQUE3QyxHQUEwRCxFQUF6RTtBQUNBeUIsNkNBQWdDekIsQ0FBaEMsV0FBc0NPLFVBQXRDLFNBQWtEYyxrQkFBa0IsV0FBU3JCLENBQTNCLENBQWxEO0FBQ0Q7QUFDRHlCLHNCQUFjLFdBQWQ7O0FBRUEvQixtRUFBeUQyQixrQkFBa0JLLGVBQTNFLGlCQUFzR0QsVUFBdEc7QUFDRDs7QUFHRCxVQUFJL0IsTUFBTU8sTUFBTixHQUFlLENBQW5CLEVBQXNCO0FBQ3BCUiwyQkFBbUJrQyxJQUFuQixDQUF3QixpQ0FBaUNqQyxLQUF6RDtBQUNBRCwyQkFBbUJtQyxXQUFuQixDQUErQjNDLE9BQU8sV0FBUCxDQUEvQjtBQUNBLGFBQUtGLEtBQUwsR0FBYUUsT0FBTyxvQkFBUCxDQUFiO0FBQ0EsYUFBSzRDLFdBQUwsQ0FBaUI1QyxPQUFPLDBCQUFQLENBQWpCO0FBQ0Q7QUFFRjs7Ozs7O2tCQXpJa0JoQiw2QiIsImZpbGUiOiIuL2pzL3NoaXB0aW1pemUtd2VpZ2h0LWJhc2VkLXNoaXBwaW5nLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqIFxuICogcGx1ZyBpbnRvIHRoZSAgZG9tIGFuZCAgYXBwZW5kIHNoaXB0aW1pemUgc2V0dGluZ3NcbiAqIFNhdmUgb24gY2hhbmdlIHZpYSBhamF4IFxuICogV2UgY2FuJ3Qgc2F2ZSBydWxlIGJ5IHJ1bGUgd2l0aG91Z2ggcGx1Z2dpbiBpbnRvIHRoZSBjaGVja291dCBcbiAqIEN1cnJlbnRseSBvbmx5IHRoZSBpbnN0YW5jZSBpZCBpcyBzYXZlZCBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hpcHRpbWl6ZVdlaWdodEJhc2VkU2hpcHBpbmcge1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGNvbnNvbGUubG9nKFwiU2hpcHRpbWl6ZSBvcHRpb25zIGZvciBXZWlnaHRCYXNlZFNoaXBwaW5nXCIpO1xuICAgIHRoaXMuaW5pdCgpO1xuXG4gIH1cblxuICBpbml0KCkge1xuICAgIC8vbm90IGEgc2hpcHBpbmcgbWV0aG9kIHBhZ2UgXG4gICAgaWYgKHR5cGVvZiAoc2hpcHRpbWl6ZV9jYXJyaWVyKSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHJlZ2V4SW5zdGFuY2UgPSAvaW5zdGFuY2VfaWQ9KFswLTldKikvLmV4ZWMod2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG5cbiAgICBpZiAoIXJlZ2V4SW5zdGFuY2UpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiaW52YWxpZCB1cmwgcGFyYW1zIGNhbm5vdCBmaW5kIGluc3RhbmNlX2lkIFwiICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pbnN0YW5jZV9pZCA9IHJlZ2V4SW5zdGFuY2VbMV07XG4gICAgdGhpcy5hdHRhY2hTaGlwdGltaXplT3B0aW9ucygpO1xuICB9XG5cbiAgLyoqIFxuICAgKiBTYXZlIG91ciBvcHRpb25zIGZvciB0aGlzIGluc3RhbmNlIFxuICAgKi9cbiAgc2F2ZU9wdGlvbnMoZWxlbSkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgJ2RhdGEnOiB0aGlzLmVGb3JtLnNlcmlhbGl6ZUFycmF5KCksXG4gICAgICAnaW5zdGFuY2VfaWQnOiB0aGlzLmluc3RhbmNlX2lkLFxuICAgICAgJ2FjdGlvbic6ICdzaGlwdGltaXplX3dic19zZXR0aW5ncydcbiAgICB9O1xuXG4gICAgalF1ZXJ5LnBvc3QoYWpheHVybCwgZGF0YSwgZnVuY3Rpb24gKHJlc3ApIHtcbiAgICAgIGNvbnNvbGUubG9nKFwicmVzcG9uc2UgXCIsIHJlc3ApO1xuICAgIH0pO1xuXG4gICAgY29uc29sZS5sb2codGhpcy5lRm9ybSwgXCJTYXZlb3B0aW9ucyBcIiwgZGF0YSk7XG4gICAgXG4gICAgalF1ZXJ5KFwiLnNoaXB0aW1pemUtb3B0aW9udmFsdWVzXCIpLmhpZGUoKTtcbiAgICB2YXIgZXh0cmFPcHRpb24gPSBqUXVlcnkoXCIuc2hpcHRpbWl6ZS1leHRyYW9wdGlvbnNcIikudmFsKCk7IFxuICAgIGpRdWVyeShcIiNzaGlwdGltaXplLWV4dHJhb3B0aW9uc1wiK2V4dHJhT3B0aW9uKS5zaG93KCk7XG4gICAgIFxuICB9XG5cbiAgLyoqIFxuICAgKiBBdHRhY2ggdGhlIHNoaXB0aW1pemUgb3B0aW9ucyB1bmRlciB0aGUgdGl0bGUgICBcbiAgICovXG4gIGF0dGFjaFNoaXB0aW1pemVPcHRpb25zKCkge1xuXG4gICAgdmFyIGVTaGlwdGltaXplT3B0aW9ucyA9IGpRdWVyeShcIjxmb3JtIGlkPSdzaGlwdGltaXplb3B0aW9ucycgY2xhc3M9XFxcIndicy1zaGlwdGltaXplb3B0aW9uc1xcXCI+PC9mb3JtPlwiKTtcbiAgICB2YXIgb0h0bWwgPSAnJztcblxuICAgIC8vbm8gb3B0aW9ucyAsIG5vdGhpbmcgdG8gZG8gXG4gICAgaWYgKHR5cGVvZiAoc2hpcHRpbWl6ZV9jYXJyaWVyLk9wdGlvbkxpc3QpID09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy9zaGlwdGltaXplX2V4dHJhb3B0aW9uc1xuICAgIC8vc2hpcHRpbWl6ZV9jaGVja2JveGVzXG4gICAgLy9BZGQgYSBTYXZlIGJ1dHRvbiBcbiAgICBsZXQgaHRtbFNlcnZpY2VMZXZlbHMgPSAnJztcbiAgICBsZXQgaHRtbEV4dHJhT3B0aW9ucyA9ICcnO1xuICAgIGxldCBodG1sQ2hlY2tib3hlcyA9ICcnO1xuICAgIGxldCBodG1sRXh0cmF2YWx1ZXMgPSAnJzsgXG4gICAgZm9yICh2YXIgeCA9IDA7IHggPCBzaGlwdGltaXplX2NhcnJpZXIuT3B0aW9uTGlzdC5sZW5ndGg7ICsreCkge1xuICAgICAgY29uc3Qgb3B0aW9uID0gc2hpcHRpbWl6ZV9jYXJyaWVyLk9wdGlvbkxpc3RbeF07XG5cbiAgICAgIGlmIChvcHRpb24uVHlwZSA9PSAxKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKG9wdGlvbi5PcHRpb25WYWx1ZXMpICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb24uT3B0aW9uVmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBsZXQgb3B0aW9uQ2hpbGQgPSBvcHRpb24uT3B0aW9uVmFsdWVzW2ldO1xuICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gc2hpcHRpbWl6ZV9vcHRpb25zWydzZXJ2aWNlX2xldmVsJ10gPT0gb3B0aW9uQ2hpbGQuSWQgPyAnc2VsZWN0ZWQnIDogJyc7XG4gICAgICAgICAgICBodG1sU2VydmljZUxldmVscyArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgb3B0aW9uQ2hpbGQuSWQgKyBcIicgXCIgKyBzZWxlY3RlZCArIFwiPlwiICsgb3B0aW9uQ2hpbGQuTmFtZSArIFwiPC9vcHRpb24+XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNoaXB0aW1pemVfZXh0cmFvcHRpb25zLmluY2x1ZGVzKG9wdGlvbi5JZCtcIlwiKSkge1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBzaGlwdGltaXplX29wdGlvbnNbJ2V4dHJhb3B0aW9ucyddID09IG9wdGlvbi5JZCA/ICdzZWxlY3RlZCcgOiAnJztcbiAgICAgICAgaHRtbEV4dHJhT3B0aW9ucyArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgb3B0aW9uLklkICsgXCInIFwiICsgc2VsZWN0ZWQgKyBcIj5cIiArIG9wdGlvbi5OYW1lICsgXCI8L29wdGlvbj5cIjtcbiAgICAgICAgaWYgKG9wdGlvbi5PcHRpb25GaWVsZHMgJiYgb3B0aW9uLk9wdGlvbkZpZWxkcy5sZW5ndGg+MCkge1xuICAgICAgICAgIGZvciAoIHZhciBqPTA7IGo8b3B0aW9uLk9wdGlvbkZpZWxkcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5PcHRpb25GaWVsZHNbal0uT3B0aW9uVmFsdWVzKSB7IFxuICAgICAgICAgICAgICB2YXIgb3B0aW9uRmllbGQgPSBvcHRpb24uT3B0aW9uRmllbGRzW2pdOyBcbiAgICAgICAgICAgICAgaHRtbEV4dHJhdmFsdWVzICs9ICc8c2VsZWN0IGNsYXNzPVwic2hpcHRpbWl6ZS1vcHRpb252YWx1ZXNcIiBpZD1cInNoaXB0aW1pemUtZXh0cmFvcHRpb25zJyArIG9wdGlvbi5JZCArICdcIiBuYW1lPVwiZXh0cmFvcHRpb25zJyArIG9wdGlvbi5JZCArICdcIiBvbmNoYW5nZT1cXFwic2hpcHRpbWl6ZS5wbGF0Zm9ybS53YnMuc2F2ZU9wdGlvbnMoalF1ZXJ5KHRoaXMpKVxcXCI+JzsgXG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9uRmllbGQuT3B0aW9uVmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgbGV0IG9wdGlvbkNoaWxkID0gb3B0aW9uRmllbGQuT3B0aW9uVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBzZWxlY3RlZCA9IHNoaXB0aW1pemVfb3B0aW9uc1snZXh0cmFvcHRpb252YWx1ZScgKyBvcHRpb24uSWRdID09IG9wdGlvbkNoaWxkLklkID8gJ3NlbGVjdGVkJyA6ICcnO1xuICAgICAgICAgICAgICAgIGh0bWxFeHRyYXZhbHVlcyArPSBcIjxvcHRpb24gdmFsdWU9J1wiICsgb3B0aW9uQ2hpbGQuSWQgKyBcIicgXCIgKyBzZWxlY3RlZCArIFwiPlwiICsgb3B0aW9uQ2hpbGQuTmFtZSArIFwiPC9vcHRpb24+XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaHRtbEV4dHJhdmFsdWVzICs9ICc8L3NlbGVjdD4nOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzaGlwdGltaXplX2NoZWNrYm94ZXMpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBpZiAob3B0aW9uLklkID09IGtleXNbaV0pIHtcbiAgICAgICAgICAgIGxldCBvcHRpb25OYW1lID0gc2hpcHRpbWl6ZV9jaGVja2JveGVzW29wdGlvbi5JZF07XG4gICAgICAgICAgICBsZXQgY2hlY2tlZCA9IHNoaXB0aW1pemVfb3B0aW9uc1tvcHRpb25OYW1lXSA9PSBvcHRpb24uSWQgPyAnY2hlY2tlZCcgOiAnJztcbiAgICAgICAgICAgIGh0bWxDaGVja2JveGVzICs9ICc8c3BhbiBjbGFzcz1cIndicy1zaGlwdGltaXplLW9wdGlvblwiPjxpbnB1dCAnICsgY2hlY2tlZCArICcgY2xhc3M9XCJ3YnMtcnNlLWNoZWNrYm94XCIgIG9uY2hhbmdlPVwic2hpcHRpbWl6ZS5wbGF0Zm9ybS53YnMuc2F2ZU9wdGlvbnMoalF1ZXJ5KHRoaXMpKVwiIHR5cGU9XCJjaGVja2JveFwiIG5hbWU9XCInICsgb3B0aW9uTmFtZSArICdcIiB2YWx1ZT1cIicgKyBvcHRpb24uSWQgKyAnXCIvPicgKyBzaGlwdGltaXplX2NoZWNrYm94ZXNbb3B0aW9uLklkXSArIFwiPC9zcGFuPlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChodG1sU2VydmljZUxldmVscy5sZW5ndGggPiAwKSB7XG4gICAgICBvSHRtbCArPSBcIjxzcGFuIGNsYXNzPVxcXCJ3YnMtc2hpcHRpbWl6ZS1vcHRpb25cXFwiPjxsYWJlbD5cIiArIHNoaXB0aW1pemVfbGFiZWxzLnNlcnZpY2VsZXZlbCArIFwiPC9sYWJlbD4gPHNlbGVjdCBuYW1lPVxcXCJzZXJ2aWNlX2xldmVsXFxcIiAgb25jaGFuZ2U9XFxcInNoaXB0aW1pemUucGxhdGZvcm0ud2JzLnNhdmVPcHRpb25zKGpRdWVyeSh0aGlzKSlcXFwiPjxvcHRpb24+LTwvb3B0aW9uPlwiICsgaHRtbFNlcnZpY2VMZXZlbHMgKyBcIjwvc2VsZWN0Pjwvc3Bhbj5cIjtcbiAgICB9XG5cbiAgICBpZiAoaHRtbEV4dHJhT3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBvSHRtbCArPSBcIjxzcGFuIGNsYXNzPVxcXCJ3YnMtc2hpcHRpbWl6ZS1vcHRpb25cXFwiPjxsYWJlbD5cIiArIHNoaXB0aW1pemVfbGFiZWxzLmV4dHJhb3B0aW9ucyArIFwiPC9sYWJlbD4gPHNlbGVjdCBjbGFzcz0nc2hpcHRpbWl6ZS1leHRyYW9wdGlvbnMnIG5hbWU9XFxcImV4dHJhb3B0aW9uc1xcXCIgIG9uY2hhbmdlPVxcXCJzaGlwdGltaXplLnBsYXRmb3JtLndicy5zYXZlT3B0aW9ucyhqUXVlcnkodGhpcykpXFxcIj48b3B0aW9uPi08L29wdGlvbj5cIiArIGh0bWxFeHRyYU9wdGlvbnMgKyBcIjwvc2VsZWN0PiBcIiArIGh0bWxFeHRyYXZhbHVlcysgXCIgPC9zcGFuPlwiO1xuICAgIH1cblxuICAgIG9IdG1sICs9IGh0bWxDaGVja2JveGVzO1xuXG4gICAgLy9QaWNrdXAgQmVoYXZpb3VyP1xuICAgIGlmKHNoaXB0aW1pemVfY2Fycmllci5IYXNQaWNrdXApIHtcbiAgICAgIGxldCBzZWxlY3RodG1sID0gJzxzZWxlY3QgY2xhc3M9XCJzaGlwdGltaXplLWV4dHJhb3B0aW9uc1wiIG5hbWU9XCJwaWNrdXBiZWhhdmlvdXJcIiBvbmNoYW5nZT1cXFwic2hpcHRpbWl6ZS5wbGF0Zm9ybS53YnMuc2F2ZU9wdGlvbnMoalF1ZXJ5KHRoaXMpKVxcXCI+JztcbiAgICAgIGZvciAodmFyIHg9MDsgeCA8IDM7ICsreCkge1xuICAgICAgICBsZXQgc2VsZWN0ZWQgPSBzaGlwdGltaXplX29wdGlvbnNbJ3BpY2t1cGJlaGF2aW91ciddID09IHggPyAnc2VsZWN0ZWQnIDogJyc7XG4gICAgICAgIHNlbGVjdGh0bWwgKz0gYDxvcHRpb24gdmFsdWU9XCIke3h9XCIgJHtzZWxlY3RlZH0+JHtzaGlwdGltaXplX2xhYmVsc1sncGlja3VwJyt4XX08L29wdGlvbj5gO1xuICAgICAgfVxuICAgICAgc2VsZWN0aHRtbCArPSAnPC9zZWxlY3Q+JztcblxuICAgICAgb0h0bWwgKz0gYDxzcGFuIGNsYXNzPVxcXCJ3YnMtc2hpcHRpbWl6ZS1vcHRpb25cXFwiPjxsYWJlbD4ke3NoaXB0aW1pemVfbGFiZWxzLnBpY2t1cGJlaGF2aW91cn08L2xhYmVsPiAke3NlbGVjdGh0bWx9PC9zcGFuPmA7XG4gICAgfSBcblxuXG4gICAgaWYgKG9IdG1sLmxlbmd0aCA+IDApIHtcbiAgICAgIGVTaGlwdGltaXplT3B0aW9ucy5odG1sKFwiPGgzPlNoaXB0aW1pemUgU2V0dGluZ3M8L2gzPlwiICsgb0h0bWwpO1xuICAgICAgZVNoaXB0aW1pemVPcHRpb25zLmluc2VydEFmdGVyKGpRdWVyeShcIiNtYWluZm9ybVwiKSk7XG4gICAgICB0aGlzLmVGb3JtID0galF1ZXJ5KFwiI3NoaXB0aW1pemVvcHRpb25zXCIpOyBcbiAgICAgIHRoaXMuc2F2ZU9wdGlvbnMoalF1ZXJ5KFwiLnNoaXB0aW1pemUtZXh0cmFvcHRpb25zXCIpKTtcbiAgICB9XG5cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/shiptimize-weight-based-shipping.js\n");

/***/ }),

/***/ "./js/shiptimize-woo-commerce-admin.js":
/*!*********************************************!*\
  !*** ./js/shiptimize-woo-commerce-admin.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _shiptimizeUtils = __webpack_require__(/*! ./shiptimize-utils.js */ \"./js/shiptimize-utils.js\");\n\nvar _shiptimizeUtils2 = _interopRequireDefault(_shiptimizeUtils);\n\nvar _shiptimizeWeightBasedShipping = __webpack_require__(/*! ./shiptimize-weight-based-shipping.js */ \"./js/shiptimize-weight-based-shipping.js\");\n\nvar _shiptimizeWeightBasedShipping2 = _interopRequireDefault(_shiptimizeWeightBasedShipping);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar WooShipitmizeAdmin = function () {\n    function WooShipitmizeAdmin() {\n        _classCallCheck(this, WooShipitmizeAdmin);\n\n        this.wbs = new _shiptimizeWeightBasedShipping2.default();\n    }\n\n    _createClass(WooShipitmizeAdmin, [{\n        key: 'bootstrap',\n        value: function bootstrap() {\n            this.urlParams();\n        }\n\n        /** \n         * If the export was successfull \n         * @param string appLink - the login url \n         */\n\n    }, {\n        key: 'exportSuccess',\n        value: function exportSuccess(appLink) {\n            if (appLink.trim().length == 0) {\n                return;\n            }\n\n            _shiptimizeUtils2.default.openNewWindow(appLink, '');\n        }\n\n        /** \n         * @param int id - the carrier id \n         */\n\n    }, {\n        key: 'getCarrier',\n        value: function getCarrier(id) {\n            for (var x = 0; x < shiptimize_carriers.length; ++x) {\n                if (shiptimize_carriers[x].Id == id) {\n                    return shiptimize_carriers[x];\n                }\n            }\n        }\n\n        /** \n         * Show aditional options for carrier \n         */\n\n    }, {\n        key: 'selectOptions',\n        value: function selectOptions(elem) {\n            this.selectServiceLevel(elem, jQuery('.shiptimize__service-level').val());\n            // hide the extra options for now \n            // this.selectExtraOptions(elem, jQuery('.shiptimize__extra-options').val());\n        }\n\n        /** \n         * @param DomElement  elem - the carrier select \n         */\n\n    }, {\n        key: 'selectServiceLevel',\n        value: function selectServiceLevel(elem, service_id) {\n            var carrier_id = elem.val();\n            var carrier = this.getCarrier(carrier_id);\n            var eServiceLevel = elem.siblings(\".shiptimize__service-level\");\n\n            var options_html = '';\n\n            if (_typeof(carrier.OptionList) != undefined) {\n                var options = carrier.OptionList;\n\n                for (var x = 0; x < options.length; ++x) {\n                    if (options[x].Type == 1 && typeof options[x].OptionValues != 'undefined') {\n                        var values = options[x].OptionValues;\n                        options_html += \"<option>-</option>\";\n                        for (var i = 0; i < values.length; ++i) {\n                            var selected = service_id == values[i].Id ? 'selected' : '';\n                            options_html += \"<option value='\" + values[i].Id + \"' \" + selected + \" >\" + values[i].Name + \"</option>\";\n                        }\n                    }\n                }\n            }\n\n            eServiceLevel.html(options_html);\n            if (options_html) {\n                eServiceLevel.addClass(\"active\");\n            } else {\n                eServiceLevel.removeClass(\"active\");\n            }\n        }\n    }, {\n        key: 'selectExtraOptions',\n        value: function selectExtraOptions(elem, selected_id) {\n            var carrier_id = elem.val();\n            var carrier = this.getCarrier(carrier_id);\n            var eExtraoptions = elem.siblings(\".shiptimize__extra-options\");\n\n            var options_html = '';\n            var option_values_html = [];\n\n            if (_typeof(carrier.OptionList) != undefined) {\n                var options = carrier.OptionList;\n                for (var x = 0; x < options.length; ++x) {\n                    if (options[x].Type == 0) {\n                        if (!options_html) {\n                            options_html += \"<option>-</option>\";\n                        }\n                        var selected = selected_id == options[x].Id ? 'selected' : '';\n                        options_html += \"<option value='\" + options[x].Id + \"' \" + selected + \" >\" + options[x].Name + \"</option>\";\n                    }\n\n                    if (options[x].OptionValues && options[x].OptionValues.length > 0) {\n                        var vhtml = '<select id=\"shiptimize-optionvalues' + options[x].Id + '\" class=\"shiptimize__optionvalues\">';\n                        for (var j = 0; j < options[x].OptionValues.length; ++j) {\n                            vhtml += '<option>' + options[x].OptionValues[j] + '</options>';\n                        }\n\n                        vhtml += '<select>';\n                    }\n                }\n            }\n\n            eExtraoptions.html(options_html);\n            if (options_html) {\n                eExtraoptions.addClass(\"active\");\n            } else {\n                eExtraoptions.removeClass(\"active\");\n            }\n        }\n    }, {\n        key: 'selectTab',\n        value: function selectTab(idx) {\n            jQuery(\".nav-tab\").removeClass('nav-tab-active');\n            jQuery(jQuery(\".nav-tab\").get(idx)).addClass('nav-tab-active');\n\n            jQuery(\".tab\").removeClass('active');\n            jQuery(jQuery(\".tab\").get(idx)).addClass('active');\n        }\n    }, {\n        key: 'accordion',\n        value: function accordion(elem) {\n            var $eparent = jQuery(elem).parent();\n            if ($eparent.hasClass('open')) {\n                $eparent.removeClass('open');\n            } else {\n                $eparent.addClass('open');\n            }\n        }\n\n        /** \n        * Is there stuff in the url params we care about? \n        **/\n\n    }, {\n        key: 'urlParams',\n        value: function urlParams() {\n            var parts = document.location.search.split('&');\n            for (var x = 0; x < parts.length; ++x) {\n                var keyval = parts[x].split('=');\n                var key = keyval[0];\n                var value = decodeURIComponent(keyval[1]);\n\n                if (key == 'CallbackURL') {\n                    console.log(\"We are creating a label\");\n                    shiptimize.openLoader(shiptimize_label_request);\n                    shiptimize.monitorLabelStatus(value);\n                }\n            }\n        }\n    }]);\n\n    return WooShipitmizeAdmin;\n}();\n\nexports.default = WooShipitmizeAdmin;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9zaGlwdGltaXplLXdvby1jb21tZXJjZS1hZG1pbi5qcz80MDA5Il0sIm5hbWVzIjpbIldvb1NoaXBpdG1pemVBZG1pbiIsIndicyIsIlNoaXB0aW1pemVXZWlnaHRCYXNlZFNoaXBwaW5nIiwidXJsUGFyYW1zIiwiYXBwTGluayIsInRyaW0iLCJsZW5ndGgiLCJVdGlscyIsIm9wZW5OZXdXaW5kb3ciLCJpZCIsIngiLCJzaGlwdGltaXplX2NhcnJpZXJzIiwiSWQiLCJlbGVtIiwic2VsZWN0U2VydmljZUxldmVsIiwialF1ZXJ5IiwidmFsIiwic2VydmljZV9pZCIsImNhcnJpZXJfaWQiLCJjYXJyaWVyIiwiZ2V0Q2FycmllciIsImVTZXJ2aWNlTGV2ZWwiLCJzaWJsaW5ncyIsIm9wdGlvbnNfaHRtbCIsIk9wdGlvbkxpc3QiLCJ1bmRlZmluZWQiLCJvcHRpb25zIiwiVHlwZSIsIk9wdGlvblZhbHVlcyIsInZhbHVlcyIsImkiLCJzZWxlY3RlZCIsIk5hbWUiLCJodG1sIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsInNlbGVjdGVkX2lkIiwiZUV4dHJhb3B0aW9ucyIsIm9wdGlvbl92YWx1ZXNfaHRtbCIsInZodG1sIiwiaiIsImlkeCIsImdldCIsIiRlcGFyZW50IiwicGFyZW50IiwiaGFzQ2xhc3MiLCJwYXJ0cyIsImRvY3VtZW50IiwibG9jYXRpb24iLCJzZWFyY2giLCJzcGxpdCIsImtleXZhbCIsImtleSIsInZhbHVlIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwiY29uc29sZSIsImxvZyIsInNoaXB0aW1pemUiLCJvcGVuTG9hZGVyIiwic2hpcHRpbWl6ZV9sYWJlbF9yZXF1ZXN0IiwibW9uaXRvckxhYmVsU3RhdHVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7Ozs7QUFDQTs7Ozs7Ozs7SUFFcUJBLGtCO0FBRWpCLGtDQUFjO0FBQUE7O0FBQ1YsYUFBS0MsR0FBTCxHQUFXLElBQUlDLHVDQUFKLEVBQVg7QUFD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bW1lcmNlLWFkbWluLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFV0aWxzIGZyb20gJy4vc2hpcHRpbWl6ZS11dGlscy5qcyc7IFxuaW1wb3J0IFNoaXB0aW1pemVXZWlnaHRCYXNlZFNoaXBwaW5nIGZyb20gJy4vc2hpcHRpbWl6ZS13ZWlnaHQtYmFzZWQtc2hpcHBpbmcuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXb29TaGlwaXRtaXplQWRtaW4geyAgICBcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLndicyA9IG5ldyBTaGlwdGltaXplV2VpZ2h0QmFzZWRTaGlwcGluZygpO1xuICAgIH1cblxuICAgIGJvb3RzdHJhcCgpIHsgXG4gICAgICAgIHRoaXMudXJsUGFyYW1zKCk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIElmIHRoZSBleHBvcnQgd2FzIHN1Y2Nlc3NmdWxsIFxuICAgICAqIEBwYXJhbSBzdHJpbmcgYXBwTGluayAtIHRoZSBsb2dpbiB1cmwgXG4gICAgICovXG4gICAgZXhwb3J0U3VjY2VzcyhhcHBMaW5rKSB7XG4gICAgICAgIGlmKGFwcExpbmsudHJpbSgpLmxlbmd0aCA9PSAwKXtcbiAgICAgICAgICAgIHJldHVybjsgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFV0aWxzLm9wZW5OZXdXaW5kb3coYXBwTGluaywgJycpOyBcbiAgICB9IFxuXG4gICAgLyoqIFxuICAgICAqIEBwYXJhbSBpbnQgaWQgLSB0aGUgY2FycmllciBpZCBcbiAgICAgKi8gXG4gICAgZ2V0Q2FycmllcihpZCl7XG4gICAgICAgIGZvciggbGV0IHggPSAwOyB4IDwgc2hpcHRpbWl6ZV9jYXJyaWVycy5sZW5ndGg7ICsreCApe1xuICAgICAgICAgICAgaWYoc2hpcHRpbWl6ZV9jYXJyaWVyc1t4XS5JZCA9PSBpZCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNoaXB0aW1pemVfY2FycmllcnNbeF07IFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIFNob3cgYWRpdGlvbmFsIG9wdGlvbnMgZm9yIGNhcnJpZXIgXG4gICAgICovIFxuICAgIHNlbGVjdE9wdGlvbnMoZWxlbSl7XG4gICAgICAgIHRoaXMuc2VsZWN0U2VydmljZUxldmVsKGVsZW0sIGpRdWVyeSgnLnNoaXB0aW1pemVfX3NlcnZpY2UtbGV2ZWwnKS52YWwoKSk7IFxuICAgICAgICAvLyBoaWRlIHRoZSBleHRyYSBvcHRpb25zIGZvciBub3cgXG4gICAgICAgIC8vIHRoaXMuc2VsZWN0RXh0cmFPcHRpb25zKGVsZW0sIGpRdWVyeSgnLnNoaXB0aW1pemVfX2V4dHJhLW9wdGlvbnMnKS52YWwoKSk7XG4gICAgfVxuXG4gICAgLyoqIFxuICAgICAqIEBwYXJhbSBEb21FbGVtZW50ICBlbGVtIC0gdGhlIGNhcnJpZXIgc2VsZWN0IFxuICAgICAqLyBcbiAgICBzZWxlY3RTZXJ2aWNlTGV2ZWwoIGVsZW0gLCBzZXJ2aWNlX2lkICkge1xuICAgICAgICBsZXQgY2Fycmllcl9pZCA9IGVsZW0udmFsKCk7IFxuICAgICAgICBsZXQgY2FycmllciA9IHRoaXMuZ2V0Q2FycmllcihjYXJyaWVyX2lkKTsgXG4gICAgICAgIGxldCBlU2VydmljZUxldmVsID0gZWxlbS5zaWJsaW5ncyhcIi5zaGlwdGltaXplX19zZXJ2aWNlLWxldmVsXCIpO1xuXG4gICAgICAgIGxldCBvcHRpb25zX2h0bWwgPSAnJztcblxuICAgICAgICBpZiggdHlwZW9mKGNhcnJpZXIuT3B0aW9uTGlzdCkgIT0gdW5kZWZpbmVkICl7XG4gICAgICAgICAgICBsZXQgb3B0aW9ucyA9IGNhcnJpZXIuT3B0aW9uTGlzdDsgXG5cbiAgICAgICAgICAgIGZvciggbGV0IHggPSAwOyB4IDwgb3B0aW9ucy5sZW5ndGg7ICsreCl7XG4gICAgICAgICAgICAgICAgaWYoIG9wdGlvbnNbeF0uVHlwZSA9PSAxICYmIHR5cGVvZihvcHRpb25zW3hdLk9wdGlvblZhbHVlcykgIT0gJ3VuZGVmaW5lZCcgKXsgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWVzID0gb3B0aW9uc1t4XS5PcHRpb25WYWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNfaHRtbCArPSBcIjxvcHRpb24+LTwvb3B0aW9uPlwiO1xuICAgICAgICAgICAgICAgICAgICBmb3IoIGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSApe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNlbGVjdGVkID0gc2VydmljZV9pZCA9PSB2YWx1ZXNbaV0uSWQgPyAnc2VsZWN0ZWQnIDonJzsgXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zX2h0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIHZhbHVlc1tpXS5JZCArIFwiJyBcIiArIHNlbGVjdGVkICsgXCIgPlwiICsgdmFsdWVzW2ldLk5hbWUgKyBcIjwvb3B0aW9uPlwiO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZVNlcnZpY2VMZXZlbC5odG1sKG9wdGlvbnNfaHRtbCk7XG4gICAgICAgIGlmKG9wdGlvbnNfaHRtbCl7XG4gICAgICAgICAgICBlU2VydmljZUxldmVsLmFkZENsYXNzKFwiYWN0aXZlXCIpOyBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVTZXJ2aWNlTGV2ZWwucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIHNlbGVjdEV4dHJhT3B0aW9ucyggZWxlbSwgc2VsZWN0ZWRfaWQgKXsgbGV0IGNhcnJpZXJfaWQgPSBlbGVtLnZhbCgpOyBcbiAgICAgICAgbGV0IGNhcnJpZXIgPSB0aGlzLmdldENhcnJpZXIoY2Fycmllcl9pZCk7IFxuICAgICAgICBsZXQgZUV4dHJhb3B0aW9ucyA9IGVsZW0uc2libGluZ3MoXCIuc2hpcHRpbWl6ZV9fZXh0cmEtb3B0aW9uc1wiKTtcblxuICAgICAgICBsZXQgb3B0aW9uc19odG1sID0gJyc7XG4gICAgICAgIGxldCBvcHRpb25fdmFsdWVzX2h0bWwgPSBbXTsgXG5cbiAgICAgICAgaWYoIHR5cGVvZihjYXJyaWVyLk9wdGlvbkxpc3QpICE9IHVuZGVmaW5lZCApe1xuICAgICAgICAgICAgbGV0IG9wdGlvbnMgPSBjYXJyaWVyLk9wdGlvbkxpc3Q7IFxuICAgICAgICAgICAgZm9yKCBsZXQgeCA9IDA7IHggPCBvcHRpb25zLmxlbmd0aDsgKyt4KXtcbiAgICAgICAgICAgICAgICBpZiggb3B0aW9uc1t4XS5UeXBlID09IDAgKXsgIFxuICAgICAgICAgICAgICAgICAgICBpZighb3B0aW9uc19odG1sKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNfaHRtbCArPSBcIjxvcHRpb24+LTwvb3B0aW9uPlwiO1xuICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWQgPSBzZWxlY3RlZF9pZCA9PSBvcHRpb25zW3hdLklkID8gJ3NlbGVjdGVkJyA6Jyc7IFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zX2h0bWwgKz0gXCI8b3B0aW9uIHZhbHVlPSdcIiArIG9wdGlvbnNbeF0uSWQgKyBcIicgXCIgKyBzZWxlY3RlZCArIFwiID5cIiArIG9wdGlvbnNbeF0uTmFtZSArIFwiPC9vcHRpb24+XCI7IFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zW3hdLk9wdGlvblZhbHVlcyAmJiBvcHRpb25zW3hdLk9wdGlvblZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB2aHRtbCA9ICc8c2VsZWN0IGlkPVwic2hpcHRpbWl6ZS1vcHRpb252YWx1ZXMnICsgb3B0aW9uc1t4XS5JZCArJ1wiIGNsYXNzPVwic2hpcHRpbWl6ZV9fb3B0aW9udmFsdWVzXCI+JztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaj0wOyBqIDwgb3B0aW9uc1t4XS5PcHRpb25WYWx1ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZodG1sICs9ICc8b3B0aW9uPicgKyBvcHRpb25zW3hdLk9wdGlvblZhbHVlc1tqXSArICc8L29wdGlvbnM+JztcbiAgICAgICAgICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgICAgICAgICB2aHRtbCArPSAnPHNlbGVjdD4nOyAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZUV4dHJhb3B0aW9ucy5odG1sKG9wdGlvbnNfaHRtbCk7XG4gICAgICAgIGlmKG9wdGlvbnNfaHRtbCl7XG4gICAgICAgICAgICBlRXh0cmFvcHRpb25zLmFkZENsYXNzKFwiYWN0aXZlXCIpOyBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVFeHRyYW9wdGlvbnMucmVtb3ZlQ2xhc3MoXCJhY3RpdmVcIik7XG4gICAgICAgIH0gXG4gICAgfSBcbiBcbiAgICBzZWxlY3RUYWIoaWR4KXtcbiAgICAgICAgalF1ZXJ5KFwiLm5hdi10YWJcIikucmVtb3ZlQ2xhc3MoJ25hdi10YWItYWN0aXZlJyk7XG4gICAgICAgIGpRdWVyeShqUXVlcnkoXCIubmF2LXRhYlwiKS5nZXQoaWR4KSkuYWRkQ2xhc3MoJ25hdi10YWItYWN0aXZlJyk7IFxuXG4gICAgICAgIGpRdWVyeShcIi50YWJcIikucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpOyBcbiAgICAgICAgalF1ZXJ5KGpRdWVyeShcIi50YWJcIikuZ2V0KGlkeCkpLmFkZENsYXNzKCdhY3RpdmUnKTtcbiAgICB9XG5cbiAgICBhY2NvcmRpb24oZWxlbSl7XG4gICAgICAgIGxldCAkZXBhcmVudCA9IGpRdWVyeShlbGVtKS5wYXJlbnQoKTsgXG4gICAgICAgIGlmICgkZXBhcmVudC5oYXNDbGFzcygnb3BlbicpKSB7XG4gICAgICAgICAgICAkZXBhcmVudC5yZW1vdmVDbGFzcygnb3BlbicpOyBcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICRlcGFyZW50LmFkZENsYXNzKCdvcGVuJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKiogXG4gICAgKiBJcyB0aGVyZSBzdHVmZiBpbiB0aGUgdXJsIHBhcmFtcyB3ZSBjYXJlIGFib3V0PyBcbiAgICAqKi9cbiAgICB1cmxQYXJhbXMoKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IGRvY3VtZW50LmxvY2F0aW9uLnNlYXJjaC5zcGxpdCgnJicpOyBcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXJ0cy5sZW5ndGg7ICsreCkge1xuICAgICAgICAgIGxldCBrZXl2YWwgPSBwYXJ0c1t4XS5zcGxpdCgnPScpOyBcbiAgICAgICAgICBsZXQga2V5ID0ga2V5dmFsWzBdO1xuICAgICAgICAgIGxldCB2YWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXl2YWxbMV0pOyBcblxuICAgICAgICAgIGlmKGtleSA9PSAnQ2FsbGJhY2tVUkwnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIldlIGFyZSBjcmVhdGluZyBhIGxhYmVsXCIpO1xuICAgICAgICAgICAgc2hpcHRpbWl6ZS5vcGVuTG9hZGVyKHNoaXB0aW1pemVfbGFiZWxfcmVxdWVzdCk7IFxuICAgICAgICAgICAgc2hpcHRpbWl6ZS5tb25pdG9yTGFiZWxTdGF0dXModmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/shiptimize-woo-commerce-admin.js\n");

/***/ }),

/***/ "./node_modules/popper.js/dist/esm/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/popper.js/dist/esm/popper.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**!\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version 1.16.1\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n\nvar timeoutDuration = function () {\n  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n      return 1;\n    }\n  }\n  return 0;\n}();\n\nfunction microtaskDebounce(fn) {\n  var called = false;\n  return function () {\n    if (called) {\n      return;\n    }\n    called = true;\n    window.Promise.resolve().then(function () {\n      called = false;\n      fn();\n    });\n  };\n}\n\nfunction taskDebounce(fn) {\n  var scheduled = false;\n  return function () {\n    if (!scheduled) {\n      scheduled = true;\n      setTimeout(function () {\n        scheduled = false;\n        fn();\n      }, timeoutDuration);\n    }\n  };\n}\n\nvar supportsMicroTasks = isBrowser && window.Promise;\n\n/**\n* Create a debounced version of a method, that's asynchronously deferred\n* but called in the minimum time possible.\n*\n* @method\n* @memberof Popper.Utils\n* @argument {Function} fn\n* @returns {Function}\n*/\nvar debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n/**\n * Check if the given variable is a function\n * @method\n * @memberof Popper.Utils\n * @argument {Any} functionToCheck - variable to check\n * @returns {Boolean} answer to: is a function?\n */\nfunction isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n}\n\n/**\n * Get CSS computed property of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Eement} element\n * @argument {String} property\n */\nfunction getStyleComputedProperty(element, property) {\n  if (element.nodeType !== 1) {\n    return [];\n  }\n  // NOTE: 1 DOM access here\n  var window = element.ownerDocument.defaultView;\n  var css = window.getComputedStyle(element, null);\n  return property ? css[property] : css;\n}\n\n/**\n * Returns the parentNode or the host of the element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} parent\n */\nfunction getParentNode(element) {\n  if (element.nodeName === 'HTML') {\n    return element;\n  }\n  return element.parentNode || element.host;\n}\n\n/**\n * Returns the scrolling parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} scroll parent\n */\nfunction getScrollParent(element) {\n  // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n  if (!element) {\n    return document.body;\n  }\n\n  switch (element.nodeName) {\n    case 'HTML':\n    case 'BODY':\n      return element.ownerDocument.body;\n    case '#document':\n      return element.body;\n  }\n\n  // Firefox want us to check `-x` and `-y` variations as well\n\n  var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n\n  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n    return element;\n  }\n\n  return getScrollParent(getParentNode(element));\n}\n\n/**\n * Returns the reference node of the reference object, or the reference object itself.\n * @method\n * @memberof Popper.Utils\n * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n * @returns {Element} parent\n */\nfunction getReferenceNode(reference) {\n  return reference && reference.referenceNode ? reference.referenceNode : reference;\n}\n\nvar isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\nvar isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n/**\n * Determines if the browser is Internet Explorer\n * @method\n * @memberof Popper.Utils\n * @param {Number} version to check\n * @returns {Boolean} isIE\n */\nfunction isIE(version) {\n  if (version === 11) {\n    return isIE11;\n  }\n  if (version === 10) {\n    return isIE10;\n  }\n  return isIE11 || isIE10;\n}\n\n/**\n * Returns the offset parent of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} offset parent\n */\nfunction getOffsetParent(element) {\n  if (!element) {\n    return document.documentElement;\n  }\n\n  var noOffsetParent = isIE(10) ? document.body : null;\n\n  // NOTE: 1 DOM access here\n  var offsetParent = element.offsetParent || null;\n  // Skip hidden elements which don't have an offsetParent\n  while (offsetParent === noOffsetParent && element.nextElementSibling) {\n    offsetParent = (element = element.nextElementSibling).offsetParent;\n  }\n\n  var nodeName = offsetParent && offsetParent.nodeName;\n\n  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n    return element ? element.ownerDocument.documentElement : document.documentElement;\n  }\n\n  // .offsetParent will return the closest TH, TD or TABLE in case\n  // no offsetParent is present, I hate this job...\n  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n    return getOffsetParent(offsetParent);\n  }\n\n  return offsetParent;\n}\n\nfunction isOffsetContainer(element) {\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY') {\n    return false;\n  }\n  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n}\n\n/**\n * Finds the root node (document, shadowDOM root) of the given element\n * @method\n * @memberof Popper.Utils\n * @argument {Element} node\n * @returns {Element} root node\n */\nfunction getRoot(node) {\n  if (node.parentNode !== null) {\n    return getRoot(node.parentNode);\n  }\n\n  return node;\n}\n\n/**\n * Finds the offset parent common to the two provided nodes\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element1\n * @argument {Element} element2\n * @returns {Element} common offset parent\n */\nfunction findCommonOffsetParent(element1, element2) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n    return document.documentElement;\n  }\n\n  // Here we make sure to give as \"start\" the element that comes first in the DOM\n  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n  var start = order ? element1 : element2;\n  var end = order ? element2 : element1;\n\n  // Get common ancestor container\n  var range = document.createRange();\n  range.setStart(start, 0);\n  range.setEnd(end, 0);\n  var commonAncestorContainer = range.commonAncestorContainer;\n\n  // Both nodes are inside #document\n\n  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n    if (isOffsetContainer(commonAncestorContainer)) {\n      return commonAncestorContainer;\n    }\n\n    return getOffsetParent(commonAncestorContainer);\n  }\n\n  // one of the nodes is inside shadowDOM, find which one\n  var element1root = getRoot(element1);\n  if (element1root.host) {\n    return findCommonOffsetParent(element1root.host, element2);\n  } else {\n    return findCommonOffsetParent(element1, getRoot(element2).host);\n  }\n}\n\n/**\n * Gets the scroll value of the given element in the given side (top and left)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {String} side `top` or `left`\n * @returns {number} amount of scrolled pixels\n */\nfunction getScroll(element) {\n  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n\n  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n  var nodeName = element.nodeName;\n\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    var html = element.ownerDocument.documentElement;\n    var scrollingElement = element.ownerDocument.scrollingElement || html;\n    return scrollingElement[upperSide];\n  }\n\n  return element[upperSide];\n}\n\n/*\n * Sum or subtract the element scroll values (left and top) from a given rect object\n * @method\n * @memberof Popper.Utils\n * @param {Object} rect - Rect object you want to change\n * @param {HTMLElement} element - The element from the function reads the scroll values\n * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n * @return {Object} rect - The modifier rect object\n */\nfunction includeScroll(rect, element) {\n  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var scrollTop = getScroll(element, 'top');\n  var scrollLeft = getScroll(element, 'left');\n  var modifier = subtract ? -1 : 1;\n  rect.top += scrollTop * modifier;\n  rect.bottom += scrollTop * modifier;\n  rect.left += scrollLeft * modifier;\n  rect.right += scrollLeft * modifier;\n  return rect;\n}\n\n/*\n * Helper to detect borders of a given element\n * @method\n * @memberof Popper.Utils\n * @param {CSSStyleDeclaration} styles\n * Result of `getStyleComputedProperty` on the given element\n * @param {String} axis - `x` or `y`\n * @return {number} borders - The borders size of the given axis\n */\n\nfunction getBordersSize(styles, axis) {\n  var sideA = axis === 'x' ? 'Left' : 'Top';\n  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n\n  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n}\n\nfunction getSize(axis, body, html, computedStyle) {\n  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n}\n\nfunction getWindowSizes(document) {\n  var body = document.body;\n  var html = document.documentElement;\n  var computedStyle = isIE(10) && getComputedStyle(html);\n\n  return {\n    height: getSize('Height', body, html, computedStyle),\n    width: getSize('Width', body, html, computedStyle)\n  };\n}\n\nvar classCallCheck = function classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar defineProperty = function defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n/**\n * Given element offsets, generate an output similar to getBoundingClientRect\n * @method\n * @memberof Popper.Utils\n * @argument {Object} offsets\n * @returns {Object} ClientRect like output\n */\nfunction getClientRect(offsets) {\n  return _extends({}, offsets, {\n    right: offsets.left + offsets.width,\n    bottom: offsets.top + offsets.height\n  });\n}\n\n/**\n * Get bounding client rect of given element\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} element\n * @return {Object} client rect\n */\nfunction getBoundingClientRect(element) {\n  var rect = {};\n\n  // IE10 10 FIX: Please, don't ask, the element isn't\n  // considered in DOM in some circumstances...\n  // This isn't reproducible in IE10 compatibility mode of IE11\n  try {\n    if (isIE(10)) {\n      rect = element.getBoundingClientRect();\n      var scrollTop = getScroll(element, 'top');\n      var scrollLeft = getScroll(element, 'left');\n      rect.top += scrollTop;\n      rect.left += scrollLeft;\n      rect.bottom += scrollTop;\n      rect.right += scrollLeft;\n    } else {\n      rect = element.getBoundingClientRect();\n    }\n  } catch (e) {}\n\n  var result = {\n    left: rect.left,\n    top: rect.top,\n    width: rect.right - rect.left,\n    height: rect.bottom - rect.top\n  };\n\n  // subtract scrollbar size from sizes\n  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n  var width = sizes.width || element.clientWidth || result.width;\n  var height = sizes.height || element.clientHeight || result.height;\n\n  var horizScrollbar = element.offsetWidth - width;\n  var vertScrollbar = element.offsetHeight - height;\n\n  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n  // we make this check conditional for performance reasons\n  if (horizScrollbar || vertScrollbar) {\n    var styles = getStyleComputedProperty(element);\n    horizScrollbar -= getBordersSize(styles, 'x');\n    vertScrollbar -= getBordersSize(styles, 'y');\n\n    result.width -= horizScrollbar;\n    result.height -= vertScrollbar;\n  }\n\n  return getClientRect(result);\n}\n\nfunction getOffsetRectRelativeToArbitraryNode(children, parent) {\n  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var isIE10 = isIE(10);\n  var isHTML = parent.nodeName === 'HTML';\n  var childrenRect = getBoundingClientRect(children);\n  var parentRect = getBoundingClientRect(parent);\n  var scrollParent = getScrollParent(children);\n\n  var styles = getStyleComputedProperty(parent);\n  var borderTopWidth = parseFloat(styles.borderTopWidth);\n  var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n  // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n  if (fixedPosition && isHTML) {\n    parentRect.top = Math.max(parentRect.top, 0);\n    parentRect.left = Math.max(parentRect.left, 0);\n  }\n  var offsets = getClientRect({\n    top: childrenRect.top - parentRect.top - borderTopWidth,\n    left: childrenRect.left - parentRect.left - borderLeftWidth,\n    width: childrenRect.width,\n    height: childrenRect.height\n  });\n  offsets.marginTop = 0;\n  offsets.marginLeft = 0;\n\n  // Subtract margins of documentElement in case it's being used as parent\n  // we do this only on HTML because it's the only element that behaves\n  // differently when margins are applied to it. The margins are included in\n  // the box of the documentElement, in the other cases not.\n  if (!isIE10 && isHTML) {\n    var marginTop = parseFloat(styles.marginTop);\n    var marginLeft = parseFloat(styles.marginLeft);\n\n    offsets.top -= borderTopWidth - marginTop;\n    offsets.bottom -= borderTopWidth - marginTop;\n    offsets.left -= borderLeftWidth - marginLeft;\n    offsets.right -= borderLeftWidth - marginLeft;\n\n    // Attach marginTop and marginLeft because in some circumstances we may need them\n    offsets.marginTop = marginTop;\n    offsets.marginLeft = marginLeft;\n  }\n\n  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n    offsets = includeScroll(offsets, parent);\n  }\n\n  return offsets;\n}\n\nfunction getViewportOffsetRectRelativeToArtbitraryNode(element) {\n  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var html = element.ownerDocument.documentElement;\n  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n  var width = Math.max(html.clientWidth, window.innerWidth || 0);\n  var height = Math.max(html.clientHeight, window.innerHeight || 0);\n\n  var scrollTop = !excludeScroll ? getScroll(html) : 0;\n  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n\n  var offset = {\n    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n    width: width,\n    height: height\n  };\n\n  return getClientRect(offset);\n}\n\n/**\n * Check if the given element is fixed or is inside a fixed parent\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @argument {Element} customContainer\n * @returns {Boolean} answer to \"isFixed?\"\n */\nfunction isFixed(element) {\n  var nodeName = element.nodeName;\n  if (nodeName === 'BODY' || nodeName === 'HTML') {\n    return false;\n  }\n  if (getStyleComputedProperty(element, 'position') === 'fixed') {\n    return true;\n  }\n  var parentNode = getParentNode(element);\n  if (!parentNode) {\n    return false;\n  }\n  return isFixed(parentNode);\n}\n\n/**\n * Finds the first parent of an element that has a transformed property defined\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Element} first transformed parent or documentElement\n */\n\nfunction getFixedPositionOffsetParent(element) {\n  // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n  if (!element || !element.parentElement || isIE()) {\n    return document.documentElement;\n  }\n  var el = element.parentElement;\n  while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n    el = el.parentElement;\n  }\n  return el || document.documentElement;\n}\n\n/**\n * Computed the boundaries limits and return them\n * @method\n * @memberof Popper.Utils\n * @param {HTMLElement} popper\n * @param {HTMLElement} reference\n * @param {number} padding\n * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n * @param {Boolean} fixedPosition - Is in fixed position mode\n * @returns {Object} Coordinates of the boundaries\n */\nfunction getBoundaries(popper, reference, padding, boundariesElement) {\n  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n  // NOTE: 1 DOM access here\n\n  var boundaries = { top: 0, left: 0 };\n  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n  // Handle viewport case\n  if (boundariesElement === 'viewport') {\n    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n  } else {\n    // Handle other cases based on DOM element used as boundaries\n    var boundariesNode = void 0;\n    if (boundariesElement === 'scrollParent') {\n      boundariesNode = getScrollParent(getParentNode(reference));\n      if (boundariesNode.nodeName === 'BODY') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      }\n    } else if (boundariesElement === 'window') {\n      boundariesNode = popper.ownerDocument.documentElement;\n    } else {\n      boundariesNode = boundariesElement;\n    }\n\n    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n    // In case of HTML, we need a different computation\n    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n      var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n\n      boundaries.top += offsets.top - offsets.marginTop;\n      boundaries.bottom = height + offsets.top;\n      boundaries.left += offsets.left - offsets.marginLeft;\n      boundaries.right = width + offsets.left;\n    } else {\n      // for all the other DOM elements, this one is good\n      boundaries = offsets;\n    }\n  }\n\n  // Add paddings\n  padding = padding || 0;\n  var isPaddingNumber = typeof padding === 'number';\n  boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n  boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n\n  return boundaries;\n}\n\nfunction getArea(_ref) {\n  var width = _ref.width,\n      height = _ref.height;\n\n  return width * height;\n}\n\n/**\n * Utility used to transform the `auto` placement to the placement with more\n * available space.\n * @method\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n\n  if (placement.indexOf('auto') === -1) {\n    return placement;\n  }\n\n  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n\n  var rects = {\n    top: {\n      width: boundaries.width,\n      height: refRect.top - boundaries.top\n    },\n    right: {\n      width: boundaries.right - refRect.right,\n      height: boundaries.height\n    },\n    bottom: {\n      width: boundaries.width,\n      height: boundaries.bottom - refRect.bottom\n    },\n    left: {\n      width: refRect.left - boundaries.left,\n      height: boundaries.height\n    }\n  };\n\n  var sortedAreas = Object.keys(rects).map(function (key) {\n    return _extends({\n      key: key\n    }, rects[key], {\n      area: getArea(rects[key])\n    });\n  }).sort(function (a, b) {\n    return b.area - a.area;\n  });\n\n  var filteredAreas = sortedAreas.filter(function (_ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    return width >= popper.clientWidth && height >= popper.clientHeight;\n  });\n\n  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n\n  var variation = placement.split('-')[1];\n\n  return computedPlacement + (variation ? '-' + variation : '');\n}\n\n/**\n * Get offsets to the reference element\n * @method\n * @memberof Popper.Utils\n * @param {Object} state\n * @param {Element} popper - the popper element\n * @param {Element} reference - the reference element (the popper will be relative to this)\n * @param {Element} fixedPosition - is in fixed position mode\n * @returns {Object} An object containing the offsets which will be applied to the popper\n */\nfunction getReferenceOffsets(state, popper, reference) {\n  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n}\n\n/**\n * Get the outer sizes of the given element (offset size + margins)\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element\n * @returns {Object} object containing width and height properties\n */\nfunction getOuterSizes(element) {\n  var window = element.ownerDocument.defaultView;\n  var styles = window.getComputedStyle(element);\n  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n  var result = {\n    width: element.offsetWidth + y,\n    height: element.offsetHeight + x\n  };\n  return result;\n}\n\n/**\n * Get the opposite placement of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement\n * @returns {String} flipped placement\n */\nfunction getOppositePlacement(placement) {\n  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n\n/**\n * Get offsets to the popper\n * @method\n * @memberof Popper.Utils\n * @param {Object} position - CSS position the Popper will get applied\n * @param {HTMLElement} popper - the popper element\n * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n * @param {String} placement - one of the valid placement options\n * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n */\nfunction getPopperOffsets(popper, referenceOffsets, placement) {\n  placement = placement.split('-')[0];\n\n  // Get popper node sizes\n  var popperRect = getOuterSizes(popper);\n\n  // Add position, width and height to our offsets object\n  var popperOffsets = {\n    width: popperRect.width,\n    height: popperRect.height\n  };\n\n  // depending by the popper placement we have to compute its offsets slightly differently\n  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n  var mainSide = isHoriz ? 'top' : 'left';\n  var secondarySide = isHoriz ? 'left' : 'top';\n  var measurement = isHoriz ? 'height' : 'width';\n  var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n\n  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n  if (placement === secondarySide) {\n    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n  } else {\n    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n  }\n\n  return popperOffsets;\n}\n\n/**\n * Mimics the `find` method of Array\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction find(arr, check) {\n  // use native find if supported\n  if (Array.prototype.find) {\n    return arr.find(check);\n  }\n\n  // use `filter` to obtain the same behavior of `find`\n  return arr.filter(check)[0];\n}\n\n/**\n * Return the index of the matching object\n * @method\n * @memberof Popper.Utils\n * @argument {Array} arr\n * @argument prop\n * @argument value\n * @returns index or -1\n */\nfunction findIndex(arr, prop, value) {\n  // use native findIndex if supported\n  if (Array.prototype.findIndex) {\n    return arr.findIndex(function (cur) {\n      return cur[prop] === value;\n    });\n  }\n\n  // use `find` + `indexOf` if `findIndex` isn't supported\n  var match = find(arr, function (obj) {\n    return obj[prop] === value;\n  });\n  return arr.indexOf(match);\n}\n\n/**\n * Loop trough the list of modifiers and run them in order,\n * each of them will then edit the data object.\n * @method\n * @memberof Popper.Utils\n * @param {dataObject} data\n * @param {Array} modifiers\n * @param {String} ends - Optional modifier name used as stopper\n * @returns {dataObject}\n */\nfunction runModifiers(modifiers, data, ends) {\n  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n\n  modifiersToRun.forEach(function (modifier) {\n    if (modifier['function']) {\n      // eslint-disable-line dot-notation\n      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n    }\n    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n    if (modifier.enabled && isFunction(fn)) {\n      // Add properties to offsets to make them a complete clientRect object\n      // we do this before each modifier to make sure the previous one doesn't\n      // mess with these values\n      data.offsets.popper = getClientRect(data.offsets.popper);\n      data.offsets.reference = getClientRect(data.offsets.reference);\n\n      data = fn(data, modifier);\n    }\n  });\n\n  return data;\n}\n\n/**\n * Updates the position of the popper, computing the new offsets and applying\n * the new style.<br />\n * Prefer `scheduleUpdate` over `update` because of performance reasons.\n * @method\n * @memberof Popper\n */\nfunction update() {\n  // if popper is destroyed, don't perform any further update\n  if (this.state.isDestroyed) {\n    return;\n  }\n\n  var data = {\n    instance: this,\n    styles: {},\n    arrowStyles: {},\n    attributes: {},\n    flipped: false,\n    offsets: {}\n  };\n\n  // compute reference element offsets\n  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n  // store the computed placement inside `originalPlacement`\n  data.originalPlacement = data.placement;\n\n  data.positionFixed = this.options.positionFixed;\n\n  // compute the popper offsets\n  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n\n  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n  // run the modifiers\n  data = runModifiers(this.modifiers, data);\n\n  // the first `update` will call `onCreate` callback\n  // the other ones will call `onUpdate` callback\n  if (!this.state.isCreated) {\n    this.state.isCreated = true;\n    this.options.onCreate(data);\n  } else {\n    this.options.onUpdate(data);\n  }\n}\n\n/**\n * Helper used to know if the given modifier is enabled.\n * @method\n * @memberof Popper.Utils\n * @returns {Boolean}\n */\nfunction isModifierEnabled(modifiers, modifierName) {\n  return modifiers.some(function (_ref) {\n    var name = _ref.name,\n        enabled = _ref.enabled;\n    return enabled && name === modifierName;\n  });\n}\n\n/**\n * Get the prefixed supported property name\n * @method\n * @memberof Popper.Utils\n * @argument {String} property (camelCase)\n * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n */\nfunction getSupportedPropertyName(property) {\n  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefix = prefixes[i];\n    var toCheck = prefix ? '' + prefix + upperProp : property;\n    if (typeof document.body.style[toCheck] !== 'undefined') {\n      return toCheck;\n    }\n  }\n  return null;\n}\n\n/**\n * Destroys the popper.\n * @method\n * @memberof Popper\n */\nfunction destroy() {\n  this.state.isDestroyed = true;\n\n  // touch DOM only if `applyStyle` modifier is enabled\n  if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n    this.popper.removeAttribute('x-placement');\n    this.popper.style.position = '';\n    this.popper.style.top = '';\n    this.popper.style.left = '';\n    this.popper.style.right = '';\n    this.popper.style.bottom = '';\n    this.popper.style.willChange = '';\n    this.popper.style[getSupportedPropertyName('transform')] = '';\n  }\n\n  this.disableEventListeners();\n\n  // remove the popper if user explicitly asked for the deletion on destroy\n  // do not use `remove` because IE11 doesn't support it\n  if (this.options.removeOnDestroy) {\n    this.popper.parentNode.removeChild(this.popper);\n  }\n  return this;\n}\n\n/**\n * Get the window associated with the element\n * @argument {Element} element\n * @returns {Window}\n */\nfunction getWindow(element) {\n  var ownerDocument = element.ownerDocument;\n  return ownerDocument ? ownerDocument.defaultView : window;\n}\n\nfunction attachToScrollParents(scrollParent, event, callback, scrollParents) {\n  var isBody = scrollParent.nodeName === 'BODY';\n  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n  target.addEventListener(event, callback, { passive: true });\n\n  if (!isBody) {\n    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n  }\n  scrollParents.push(target);\n}\n\n/**\n * Setup needed event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction setupEventListeners(reference, options, state, updateBound) {\n  // Resize event listener on window\n  state.updateBound = updateBound;\n  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });\n\n  // Scroll event listener on scroll parents\n  var scrollElement = getScrollParent(reference);\n  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n  state.scrollElement = scrollElement;\n  state.eventsEnabled = true;\n\n  return state;\n}\n\n/**\n * It will add resize/scroll events and start recalculating\n * position of the popper element when they are triggered.\n * @method\n * @memberof Popper\n */\nfunction enableEventListeners() {\n  if (!this.state.eventsEnabled) {\n    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n  }\n}\n\n/**\n * Remove event listeners used to update the popper position\n * @method\n * @memberof Popper.Utils\n * @private\n */\nfunction removeEventListeners(reference, state) {\n  // Remove resize event listener on window\n  getWindow(reference).removeEventListener('resize', state.updateBound);\n\n  // Remove scroll event listener on scroll parents\n  state.scrollParents.forEach(function (target) {\n    target.removeEventListener('scroll', state.updateBound);\n  });\n\n  // Reset state\n  state.updateBound = null;\n  state.scrollParents = [];\n  state.scrollElement = null;\n  state.eventsEnabled = false;\n  return state;\n}\n\n/**\n * It will remove resize/scroll events and won't recalculate popper position\n * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n * unless you call `update` method manually.\n * @method\n * @memberof Popper\n */\nfunction disableEventListeners() {\n  if (this.state.eventsEnabled) {\n    cancelAnimationFrame(this.scheduleUpdate);\n    this.state = removeEventListeners(this.reference, this.state);\n  }\n}\n\n/**\n * Tells if a given input is a number\n * @method\n * @memberof Popper.Utils\n * @param {*} input to check\n * @return {Boolean}\n */\nfunction isNumeric(n) {\n  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n}\n\n/**\n * Set the style to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the style to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setStyles(element, styles) {\n  Object.keys(styles).forEach(function (prop) {\n    var unit = '';\n    // add unit if the value is numeric and is one of the following\n    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n      unit = 'px';\n    }\n    element.style[prop] = styles[prop] + unit;\n  });\n}\n\n/**\n * Set the attributes to the given popper\n * @method\n * @memberof Popper.Utils\n * @argument {Element} element - Element to apply the attributes to\n * @argument {Object} styles\n * Object with a list of properties and values which will be applied to the element\n */\nfunction setAttributes(element, attributes) {\n  Object.keys(attributes).forEach(function (prop) {\n    var value = attributes[prop];\n    if (value !== false) {\n      element.setAttribute(prop, attributes[prop]);\n    } else {\n      element.removeAttribute(prop);\n    }\n  });\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} data.styles - List of style properties - values to apply to popper element\n * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The same data object\n */\nfunction applyStyle(data) {\n  // any property present in `data.styles` will be applied to the popper,\n  // in this way we can make the 3rd party modifiers add custom styles to it\n  // Be aware, modifiers could override the properties defined in the previous\n  // lines of this modifier!\n  setStyles(data.instance.popper, data.styles);\n\n  // any property present in `data.attributes` will be applied to the popper,\n  // they will be set as HTML attributes of the element\n  setAttributes(data.instance.popper, data.attributes);\n\n  // if arrowElement is defined and arrowStyles has some properties\n  if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n    setStyles(data.arrowElement, data.arrowStyles);\n  }\n\n  return data;\n}\n\n/**\n * Set the x-placement attribute before everything else because it could be used\n * to add margins to the popper margins needs to be calculated to get the\n * correct popper offsets.\n * @method\n * @memberof Popper.modifiers\n * @param {HTMLElement} reference - The reference element used to position the popper\n * @param {HTMLElement} popper - The HTML element used as popper\n * @param {Object} options - Popper.js options\n */\nfunction applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n  // compute reference element offsets\n  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n  // compute auto placement, store placement inside the data object,\n  // modifiers will be able to edit `placement` if needed\n  // and refer to originalPlacement to know the original value\n  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n\n  popper.setAttribute('x-placement', placement);\n\n  // Apply `position` to popper before anything else because\n  // without the position applied we can't guarantee correct computations\n  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });\n\n  return options;\n}\n\n/**\n * @function\n * @memberof Popper.Utils\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n * @returns {Object} The popper's position offsets rounded\n *\n * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n * good as it can be within reason.\n * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n *\n * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n * as well on High DPI screens).\n *\n * Firefox prefers no rounding for positioning and does not have blurriness on\n * high DPI screens.\n *\n * Only horizontal placement and left/right values need to be considered.\n */\nfunction getRoundedOffsets(data, shouldRound) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n  var round = Math.round,\n      floor = Math.floor;\n\n  var noRound = function noRound(v) {\n    return v;\n  };\n\n  var referenceWidth = round(reference.width);\n  var popperWidth = round(popper.width);\n\n  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n  var isVariation = data.placement.indexOf('-') !== -1;\n  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n\n  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n  var verticalToInteger = !shouldRound ? noRound : round;\n\n  return {\n    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n    top: verticalToInteger(popper.top),\n    bottom: verticalToInteger(popper.bottom),\n    right: horizontalToInteger(popper.right)\n  };\n}\n\nvar isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction computeStyle(data, options) {\n  var x = options.x,\n      y = options.y;\n  var popper = data.offsets.popper;\n\n  // Remove this legacy support in Popper.js v2\n\n  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'applyStyle';\n  }).gpuAcceleration;\n  if (legacyGpuAccelerationOption !== undefined) {\n    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n  }\n  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n\n  var offsetParent = getOffsetParent(data.instance.popper);\n  var offsetParentRect = getBoundingClientRect(offsetParent);\n\n  // Styles\n  var styles = {\n    position: popper.position\n  };\n\n  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n\n  var sideA = x === 'bottom' ? 'top' : 'bottom';\n  var sideB = y === 'right' ? 'left' : 'right';\n\n  // if gpuAcceleration is set to `true` and transform is supported,\n  //  we use `translate3d` to apply the position to the popper we\n  // automatically use the supported prefixed version if needed\n  var prefixedProperty = getSupportedPropertyName('transform');\n\n  // now, let's make a step back and look at this code closely (wtf?)\n  // If the content of the popper grows once it's been positioned, it\n  // may happen that the popper gets misplaced because of the new content\n  // overflowing its reference element\n  // To avoid this problem, we provide two options (x and y), which allow\n  // the consumer to define the offset origin.\n  // If we position a popper on top of a reference element, we can set\n  // `x` to `top` to make the popper grow towards its top instead of\n  // its bottom.\n  var left = void 0,\n      top = void 0;\n  if (sideA === 'bottom') {\n    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n    // and not the bottom of the html element\n    if (offsetParent.nodeName === 'HTML') {\n      top = -offsetParent.clientHeight + offsets.bottom;\n    } else {\n      top = -offsetParentRect.height + offsets.bottom;\n    }\n  } else {\n    top = offsets.top;\n  }\n  if (sideB === 'right') {\n    if (offsetParent.nodeName === 'HTML') {\n      left = -offsetParent.clientWidth + offsets.right;\n    } else {\n      left = -offsetParentRect.width + offsets.right;\n    }\n  } else {\n    left = offsets.left;\n  }\n  if (gpuAcceleration && prefixedProperty) {\n    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n    styles[sideA] = 0;\n    styles[sideB] = 0;\n    styles.willChange = 'transform';\n  } else {\n    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n    var invertTop = sideA === 'bottom' ? -1 : 1;\n    var invertLeft = sideB === 'right' ? -1 : 1;\n    styles[sideA] = top * invertTop;\n    styles[sideB] = left * invertLeft;\n    styles.willChange = sideA + ', ' + sideB;\n  }\n\n  // Attributes\n  var attributes = {\n    'x-placement': data.placement\n  };\n\n  // Update `data` attributes, styles and arrowStyles\n  data.attributes = _extends({}, attributes, data.attributes);\n  data.styles = _extends({}, styles, data.styles);\n  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n\n  return data;\n}\n\n/**\n * Helper used to know if the given modifier depends from another one.<br />\n * It checks if the needed modifier is listed and enabled.\n * @method\n * @memberof Popper.Utils\n * @param {Array} modifiers - list of modifiers\n * @param {String} requestingName - name of requesting modifier\n * @param {String} requestedName - name of requested modifier\n * @returns {Boolean}\n */\nfunction isModifierRequired(modifiers, requestingName, requestedName) {\n  var requesting = find(modifiers, function (_ref) {\n    var name = _ref.name;\n    return name === requestingName;\n  });\n\n  var isRequired = !!requesting && modifiers.some(function (modifier) {\n    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n  });\n\n  if (!isRequired) {\n    var _requesting = '`' + requestingName + '`';\n    var requested = '`' + requestedName + '`';\n    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n  }\n  return isRequired;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction arrow(data, options) {\n  var _data$offsets$arrow;\n\n  // arrow depends on keepTogether in order to work\n  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n    return data;\n  }\n\n  var arrowElement = options.element;\n\n  // if arrowElement is a string, suppose it's a CSS selector\n  if (typeof arrowElement === 'string') {\n    arrowElement = data.instance.popper.querySelector(arrowElement);\n\n    // if arrowElement is not found, don't run the modifier\n    if (!arrowElement) {\n      return data;\n    }\n  } else {\n    // if the arrowElement isn't a query selector we must check that the\n    // provided DOM node is child of its popper node\n    if (!data.instance.popper.contains(arrowElement)) {\n      console.warn('WARNING: `arrow.element` must be child of its popper element!');\n      return data;\n    }\n  }\n\n  var placement = data.placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n\n  var len = isVertical ? 'height' : 'width';\n  var sideCapitalized = isVertical ? 'Top' : 'Left';\n  var side = sideCapitalized.toLowerCase();\n  var altSide = isVertical ? 'left' : 'top';\n  var opSide = isVertical ? 'bottom' : 'right';\n  var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n  //\n  // extends keepTogether behavior making sure the popper and its\n  // reference have enough pixels in conjunction\n  //\n\n  // top/left side\n  if (reference[opSide] - arrowElementSize < popper[side]) {\n    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n  }\n  // bottom/right side\n  if (reference[side] + arrowElementSize > popper[opSide]) {\n    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n  }\n  data.offsets.popper = getClientRect(data.offsets.popper);\n\n  // compute center of the popper\n  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n  // Compute the sideValue using the updated popper offsets\n  // take popper margin in account because we don't have this info available\n  var css = getStyleComputedProperty(data.instance.popper);\n  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n  // prevent arrowElement from being placed not contiguously to its popper\n  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n\n  data.arrowElement = arrowElement;\n  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n\n  return data;\n}\n\n/**\n * Get the opposite placement variation of the given one\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement variation\n * @returns {String} flipped placement variation\n */\nfunction getOppositeVariation(variation) {\n  if (variation === 'end') {\n    return 'start';\n  } else if (variation === 'start') {\n    return 'end';\n  }\n  return variation;\n}\n\n/**\n * List of accepted placements to use as values of the `placement` option.<br />\n * Valid placements are:\n * - `auto`\n * - `top`\n * - `right`\n * - `bottom`\n * - `left`\n *\n * Each placement can have a variation from this list:\n * - `-start`\n * - `-end`\n *\n * Variations are interpreted easily if you think of them as the left to right\n * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n * is right.<br />\n * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n *\n * Some valid examples are:\n * - `top-end` (on top of reference, right aligned)\n * - `right-start` (on right of reference, top aligned)\n * - `bottom` (on bottom, centered)\n * - `auto-end` (on the side with more space available, alignment depends by placement)\n *\n * @static\n * @type {Array}\n * @enum {String}\n * @readonly\n * @method placements\n * @memberof Popper\n */\nvar placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n// Get rid of `auto` `auto-start` and `auto-end`\nvar validPlacements = placements.slice(3);\n\n/**\n * Given an initial placement, returns all the subsequent placements\n * clockwise (or counter-clockwise).\n *\n * @method\n * @memberof Popper.Utils\n * @argument {String} placement - A valid placement (it accepts variations)\n * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n * @returns {Array} placements including their variations\n */\nfunction clockwise(placement) {\n  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  var index = validPlacements.indexOf(placement);\n  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n  return counter ? arr.reverse() : arr;\n}\n\nvar BEHAVIORS = {\n  FLIP: 'flip',\n  CLOCKWISE: 'clockwise',\n  COUNTERCLOCKWISE: 'counterclockwise'\n};\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction flip(data, options) {\n  // if `inner` modifier is enabled, we can't use the `flip` modifier\n  if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n    return data;\n  }\n\n  if (data.flipped && data.placement === data.originalPlacement) {\n    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n    return data;\n  }\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n\n  var placement = data.placement.split('-')[0];\n  var placementOpposite = getOppositePlacement(placement);\n  var variation = data.placement.split('-')[1] || '';\n\n  var flipOrder = [];\n\n  switch (options.behavior) {\n    case BEHAVIORS.FLIP:\n      flipOrder = [placement, placementOpposite];\n      break;\n    case BEHAVIORS.CLOCKWISE:\n      flipOrder = clockwise(placement);\n      break;\n    case BEHAVIORS.COUNTERCLOCKWISE:\n      flipOrder = clockwise(placement, true);\n      break;\n    default:\n      flipOrder = options.behavior;\n  }\n\n  flipOrder.forEach(function (step, index) {\n    if (placement !== step || flipOrder.length === index + 1) {\n      return data;\n    }\n\n    placement = data.placement.split('-')[0];\n    placementOpposite = getOppositePlacement(placement);\n\n    var popperOffsets = data.offsets.popper;\n    var refOffsets = data.offsets.reference;\n\n    // using floor because the reference offsets may contain decimals we are not going to consider here\n    var floor = Math.floor;\n    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n\n    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n\n    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n    // flip the variation if required\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n    // flips variation if reference element overflows boundaries\n    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n    // flips variation if popper content overflows boundaries\n    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n\n    var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n\n    if (overlapsRef || overflowsBoundaries || flippedVariation) {\n      // this boolean to detect any flip loop\n      data.flipped = true;\n\n      if (overlapsRef || overflowsBoundaries) {\n        placement = flipOrder[index + 1];\n      }\n\n      if (flippedVariation) {\n        variation = getOppositeVariation(variation);\n      }\n\n      data.placement = placement + (variation ? '-' + variation : '');\n\n      // this object contains `position`, we want to preserve it along with\n      // any additional property we may add in the future\n      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n\n      data = runModifiers(data.instance.modifiers, data, 'flip');\n    }\n  });\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction keepTogether(data) {\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var placement = data.placement.split('-')[0];\n  var floor = Math.floor;\n  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n  var side = isVertical ? 'right' : 'bottom';\n  var opSide = isVertical ? 'left' : 'top';\n  var measurement = isVertical ? 'width' : 'height';\n\n  if (popper[side] < floor(reference[opSide])) {\n    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n  }\n  if (popper[opSide] > floor(reference[side])) {\n    data.offsets.popper[opSide] = floor(reference[side]);\n  }\n\n  return data;\n}\n\n/**\n * Converts a string containing value + unit into a px value number\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} str - Value + unit string\n * @argument {String} measurement - `height` or `width`\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @returns {Number|String}\n * Value in pixels, or original string if no values were extracted\n */\nfunction toValue(str, measurement, popperOffsets, referenceOffsets) {\n  // separate value from unit\n  var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n  var value = +split[1];\n  var unit = split[2];\n\n  // If it's not a number it's an operator, I guess\n  if (!value) {\n    return str;\n  }\n\n  if (unit.indexOf('%') === 0) {\n    var element = void 0;\n    switch (unit) {\n      case '%p':\n        element = popperOffsets;\n        break;\n      case '%':\n      case '%r':\n      default:\n        element = referenceOffsets;\n    }\n\n    var rect = getClientRect(element);\n    return rect[measurement] / 100 * value;\n  } else if (unit === 'vh' || unit === 'vw') {\n    // if is a vh or vw, we calculate the size based on the viewport\n    var size = void 0;\n    if (unit === 'vh') {\n      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n    } else {\n      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n    }\n    return size / 100 * value;\n  } else {\n    // if is an explicit pixel unit, we get rid of the unit and keep the value\n    // if is an implicit unit, it's px, and we return just the value\n    return value;\n  }\n}\n\n/**\n * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n * @function\n * @memberof {modifiers~offset}\n * @private\n * @argument {String} offset\n * @argument {Object} popperOffsets\n * @argument {Object} referenceOffsets\n * @argument {String} basePlacement\n * @returns {Array} a two cells array with x and y offsets in numbers\n */\nfunction parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n  var offsets = [0, 0];\n\n  // Use height if placement is left or right and index is 0 otherwise use width\n  // in this way the first offset will use an axis and the second one\n  // will use the other one\n  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n  // Split the offset string to obtain a list of values and operands\n  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n  var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n    return frag.trim();\n  });\n\n  // Detect if the offset string contains a pair of values or a single one\n  // they could be separated by comma or space\n  var divider = fragments.indexOf(find(fragments, function (frag) {\n    return frag.search(/,|\\s/) !== -1;\n  }));\n\n  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n  }\n\n  // If divider is found, we divide the list of values and operands to divide\n  // them by ofset X and Y.\n  var splitRegex = /\\s*,\\s*|\\s+/;\n  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n  // Convert the values with units to absolute pixels to allow our computations\n  ops = ops.map(function (op, index) {\n    // Most of the units rely on the orientation of the popper\n    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n    var mergeWithPrevious = false;\n    return op\n    // This aggregates any `+` or `-` sign that aren't considered operators\n    // e.g.: 10 + +5 => [10, +, +5]\n    .reduce(function (a, b) {\n      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n        a[a.length - 1] = b;\n        mergeWithPrevious = true;\n        return a;\n      } else if (mergeWithPrevious) {\n        a[a.length - 1] += b;\n        mergeWithPrevious = false;\n        return a;\n      } else {\n        return a.concat(b);\n      }\n    }, [])\n    // Here we convert the string values into number values (in px)\n    .map(function (str) {\n      return toValue(str, measurement, popperOffsets, referenceOffsets);\n    });\n  });\n\n  // Loop trough the offsets arrays and execute the operations\n  ops.forEach(function (op, index) {\n    op.forEach(function (frag, index2) {\n      if (isNumeric(frag)) {\n        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n      }\n    });\n  });\n  return offsets;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @argument {Number|String} options.offset=0\n * The offset value as described in the modifier description\n * @returns {Object} The data object, properly modified\n */\nfunction offset(data, _ref) {\n  var offset = _ref.offset;\n  var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var basePlacement = placement.split('-')[0];\n\n  var offsets = void 0;\n  if (isNumeric(+offset)) {\n    offsets = [+offset, 0];\n  } else {\n    offsets = parseOffset(offset, popper, reference, basePlacement);\n  }\n\n  if (basePlacement === 'left') {\n    popper.top += offsets[0];\n    popper.left -= offsets[1];\n  } else if (basePlacement === 'right') {\n    popper.top += offsets[0];\n    popper.left += offsets[1];\n  } else if (basePlacement === 'top') {\n    popper.left += offsets[0];\n    popper.top -= offsets[1];\n  } else if (basePlacement === 'bottom') {\n    popper.left += offsets[0];\n    popper.top += offsets[1];\n  }\n\n  data.popper = popper;\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction preventOverflow(data, options) {\n  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n  // If offsetParent is the reference element, we really want to\n  // go one step up and use the next offsetParent as reference to\n  // avoid to make this modifier completely useless and look like broken\n  if (data.instance.reference === boundariesElement) {\n    boundariesElement = getOffsetParent(boundariesElement);\n  }\n\n  // NOTE: DOM access here\n  // resets the popper's position so that the document size can be calculated excluding\n  // the size of the popper element itself\n  var transformProp = getSupportedPropertyName('transform');\n  var popperStyles = data.instance.popper.style; // assignment to help minification\n  var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n\n  popperStyles.top = '';\n  popperStyles.left = '';\n  popperStyles[transformProp] = '';\n\n  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n  // NOTE: DOM access here\n  // restores the original style properties after the offsets have been computed\n  popperStyles.top = top;\n  popperStyles.left = left;\n  popperStyles[transformProp] = transform;\n\n  options.boundaries = boundaries;\n\n  var order = options.priority;\n  var popper = data.offsets.popper;\n\n  var check = {\n    primary: function primary(placement) {\n      var value = popper[placement];\n      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n        value = Math.max(popper[placement], boundaries[placement]);\n      }\n      return defineProperty({}, placement, value);\n    },\n    secondary: function secondary(placement) {\n      var mainSide = placement === 'right' ? 'left' : 'top';\n      var value = popper[mainSide];\n      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n      }\n      return defineProperty({}, mainSide, value);\n    }\n  };\n\n  order.forEach(function (placement) {\n    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n    popper = _extends({}, popper, check[side](placement));\n  });\n\n  data.offsets.popper = popper;\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction shift(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var shiftvariation = placement.split('-')[1];\n\n  // if shift shiftvariation is specified, run the modifier\n  if (shiftvariation) {\n    var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n\n    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n    var side = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n\n    var shiftOffsets = {\n      start: defineProperty({}, side, reference[side]),\n      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n    };\n\n    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by update method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction hide(data) {\n  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n    return data;\n  }\n\n  var refRect = data.offsets.reference;\n  var bound = find(data.instance.modifiers, function (modifier) {\n    return modifier.name === 'preventOverflow';\n  }).boundaries;\n\n  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === true) {\n      return data;\n    }\n\n    data.hide = true;\n    data.attributes['x-out-of-boundaries'] = '';\n  } else {\n    // Avoid unnecessary DOM access if visibility hasn't changed\n    if (data.hide === false) {\n      return data;\n    }\n\n    data.hide = false;\n    data.attributes['x-out-of-boundaries'] = false;\n  }\n\n  return data;\n}\n\n/**\n * @function\n * @memberof Modifiers\n * @argument {Object} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {Object} The data object, properly modified\n */\nfunction inner(data) {\n  var placement = data.placement;\n  var basePlacement = placement.split('-')[0];\n  var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n\n  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n\n  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n\n  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n\n  data.placement = getOppositePlacement(placement);\n  data.offsets.popper = getClientRect(popper);\n\n  return data;\n}\n\n/**\n * Modifier function, each modifier can have a function of this type assigned\n * to its `fn` property.<br />\n * These functions will be called on each update, this means that you must\n * make sure they are performant enough to avoid performance bottlenecks.\n *\n * @function ModifierFn\n * @argument {dataObject} data - The data object generated by `update` method\n * @argument {Object} options - Modifiers configuration and options\n * @returns {dataObject} The data object, properly modified\n */\n\n/**\n * Modifiers are plugins used to alter the behavior of your poppers.<br />\n * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n * needed by the library.\n *\n * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n * All the other properties are configurations that could be tweaked.\n * @namespace modifiers\n */\nvar modifiers = {\n  /**\n   * Modifier used to shift the popper on the start or end of its reference\n   * element.<br />\n   * It will read the variation of the `placement` property.<br />\n   * It can be one either `-end` or `-start`.\n   * @memberof modifiers\n   * @inner\n   */\n  shift: {\n    /** @prop {number} order=100 - Index used to define the order of execution */\n    order: 100,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: shift\n  },\n\n  /**\n   * The `offset` modifier can shift your popper on both its axis.\n   *\n   * It accepts the following units:\n   * - `px` or unit-less, interpreted as pixels\n   * - `%` or `%r`, percentage relative to the length of the reference element\n   * - `%p`, percentage relative to the length of the popper element\n   * - `vw`, CSS viewport width unit\n   * - `vh`, CSS viewport height unit\n   *\n   * For length is intended the main axis relative to the placement of the popper.<br />\n   * This means that if the placement is `top` or `bottom`, the length will be the\n   * `width`. In case of `left` or `right`, it will be the `height`.\n   *\n   * You can provide a single value (as `Number` or `String`), or a pair of values\n   * as `String` divided by a comma or one (or more) white spaces.<br />\n   * The latter is a deprecated method because it leads to confusion and will be\n   * removed in v2.<br />\n   * Additionally, it accepts additions and subtractions between different units.\n   * Note that multiplications and divisions aren't supported.\n   *\n   * Valid examples are:\n   * ```\n   * 10\n   * '10%'\n   * '10, 10'\n   * '10%, 10'\n   * '10 + 10%'\n   * '10 - 5vh + 3%'\n   * '-10px + 5vh, 5px - 6%'\n   * ```\n   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  offset: {\n    /** @prop {number} order=200 - Index used to define the order of execution */\n    order: 200,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: offset,\n    /** @prop {Number|String} offset=0\n     * The offset value as described in the modifier description\n     */\n    offset: 0\n  },\n\n  /**\n   * Modifier used to prevent the popper from being positioned outside the boundary.\n   *\n   * A scenario exists where the reference itself is not within the boundaries.<br />\n   * We can say it has \"escaped the boundaries\" — or just \"escaped\".<br />\n   * In this case we need to decide whether the popper should either:\n   *\n   * - detach from the reference and remain \"trapped\" in the boundaries, or\n   * - if it should ignore the boundary and \"escape with its reference\"\n   *\n   * When `escapeWithReference` is set to`true` and reference is completely\n   * outside its boundaries, the popper will overflow (or completely leave)\n   * the boundaries in order to remain attached to the edge of the reference.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  preventOverflow: {\n    /** @prop {number} order=300 - Index used to define the order of execution */\n    order: 300,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: preventOverflow,\n    /**\n     * @prop {Array} [priority=['left','right','top','bottom']]\n     * Popper will try to prevent overflow following these priorities by default,\n     * then, it could overflow on the left and on top of the `boundariesElement`\n     */\n    priority: ['left', 'right', 'top', 'bottom'],\n    /**\n     * @prop {number} padding=5\n     * Amount of pixel used to define a minimum distance between the boundaries\n     * and the popper. This makes sure the popper always has a little padding\n     * between the edges of its container\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='scrollParent'\n     * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n     * `viewport` or any DOM element.\n     */\n    boundariesElement: 'scrollParent'\n  },\n\n  /**\n   * Modifier used to make sure the reference and its popper stay near each other\n   * without leaving any gap between the two. Especially useful when the arrow is\n   * enabled and you want to ensure that it points to its reference element.\n   * It cares only about the first axis. You can still have poppers with margin\n   * between the popper and its reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  keepTogether: {\n    /** @prop {number} order=400 - Index used to define the order of execution */\n    order: 400,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: keepTogether\n  },\n\n  /**\n   * This modifier is used to move the `arrowElement` of the popper to make\n   * sure it is positioned between the reference element and its popper element.\n   * It will read the outer size of the `arrowElement` node to detect how many\n   * pixels of conjunction are needed.\n   *\n   * It has no effect if no `arrowElement` is provided.\n   * @memberof modifiers\n   * @inner\n   */\n  arrow: {\n    /** @prop {number} order=500 - Index used to define the order of execution */\n    order: 500,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: arrow,\n    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n    element: '[x-arrow]'\n  },\n\n  /**\n   * Modifier used to flip the popper's placement when it starts to overlap its\n   * reference element.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   *\n   * **NOTE:** this modifier will interrupt the current update cycle and will\n   * restart it if it detects the need to flip the placement.\n   * @memberof modifiers\n   * @inner\n   */\n  flip: {\n    /** @prop {number} order=600 - Index used to define the order of execution */\n    order: 600,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: flip,\n    /**\n     * @prop {String|Array} behavior='flip'\n     * The behavior used to change the popper's placement. It can be one of\n     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n     * placements (with optional variations)\n     */\n    behavior: 'flip',\n    /**\n     * @prop {number} padding=5\n     * The popper will flip if it hits the edges of the `boundariesElement`\n     */\n    padding: 5,\n    /**\n     * @prop {String|HTMLElement} boundariesElement='viewport'\n     * The element which will define the boundaries of the popper position.\n     * The popper will never be placed outside of the defined boundaries\n     * (except if `keepTogether` is enabled)\n     */\n    boundariesElement: 'viewport',\n    /**\n     * @prop {Boolean} flipVariations=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the reference element overlaps its boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariations: false,\n    /**\n     * @prop {Boolean} flipVariationsByContent=false\n     * The popper will switch placement variation between `-start` and `-end` when\n     * the popper element overlaps its reference boundaries.\n     *\n     * The original placement should have a set variation.\n     */\n    flipVariationsByContent: false\n  },\n\n  /**\n   * Modifier used to make the popper flow toward the inner of the reference element.\n   * By default, when this modifier is disabled, the popper will be placed outside\n   * the reference element.\n   * @memberof modifiers\n   * @inner\n   */\n  inner: {\n    /** @prop {number} order=700 - Index used to define the order of execution */\n    order: 700,\n    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n    enabled: false,\n    /** @prop {ModifierFn} */\n    fn: inner\n  },\n\n  /**\n   * Modifier used to hide the popper when its reference element is outside of the\n   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n   * be used to hide with a CSS selector the popper when its reference is\n   * out of boundaries.\n   *\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * @memberof modifiers\n   * @inner\n   */\n  hide: {\n    /** @prop {number} order=800 - Index used to define the order of execution */\n    order: 800,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: hide\n  },\n\n  /**\n   * Computes the style that will be applied to the popper element to gets\n   * properly positioned.\n   *\n   * Note that this modifier will not touch the DOM, it just prepares the styles\n   * so that `applyStyle` modifier can apply it. This separation is useful\n   * in case you need to replace `applyStyle` with a custom implementation.\n   *\n   * This modifier has `850` as `order` value to maintain backward compatibility\n   * with previous versions of Popper.js. Expect the modifiers ordering method\n   * to change in future major versions of the library.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  computeStyle: {\n    /** @prop {number} order=850 - Index used to define the order of execution */\n    order: 850,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: computeStyle,\n    /**\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: true,\n    /**\n     * @prop {string} [x='bottom']\n     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n     * Change this if your popper should grow in a direction different from `bottom`\n     */\n    x: 'bottom',\n    /**\n     * @prop {string} [x='left']\n     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n     * Change this if your popper should grow in a direction different from `right`\n     */\n    y: 'right'\n  },\n\n  /**\n   * Applies the computed styles to the popper element.\n   *\n   * All the DOM manipulations are limited to this modifier. This is useful in case\n   * you want to integrate Popper.js inside a framework or view library and you\n   * want to delegate all the DOM manipulations to it.\n   *\n   * Note that if you disable this modifier, you must make sure the popper element\n   * has its position set to `absolute` before Popper.js can do its work!\n   *\n   * Just disable this modifier and define your own to achieve the desired effect.\n   *\n   * @memberof modifiers\n   * @inner\n   */\n  applyStyle: {\n    /** @prop {number} order=900 - Index used to define the order of execution */\n    order: 900,\n    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n    enabled: true,\n    /** @prop {ModifierFn} */\n    fn: applyStyle,\n    /** @prop {Function} */\n    onLoad: applyStyleOnLoad,\n    /**\n     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n     * @prop {Boolean} gpuAcceleration=true\n     * If true, it uses the CSS 3D transformation to position the popper.\n     * Otherwise, it will use the `top` and `left` properties\n     */\n    gpuAcceleration: undefined\n  }\n};\n\n/**\n * The `dataObject` is an object containing all the information used by Popper.js.\n * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n * @name dataObject\n * @property {Object} data.instance The Popper.js instance\n * @property {String} data.placement Placement applied to popper\n * @property {String} data.originalPlacement Placement originally defined on init\n * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n * @property {Object} data.boundaries Offsets of the popper boundaries\n * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n */\n\n/**\n * Default options provided to Popper.js constructor.<br />\n * These can be overridden using the `options` argument of Popper.js.<br />\n * To override an option, simply pass an object with the same\n * structure of the `options` object, as the 3rd argument. For example:\n * ```\n * new Popper(ref, pop, {\n *   modifiers: {\n *     preventOverflow: { enabled: false }\n *   }\n * })\n * ```\n * @type {Object}\n * @static\n * @memberof Popper\n */\nvar Defaults = {\n  /**\n   * Popper's placement.\n   * @prop {Popper.placements} placement='bottom'\n   */\n  placement: 'bottom',\n\n  /**\n   * Set this to true if you want popper to position it self in 'fixed' mode\n   * @prop {Boolean} positionFixed=false\n   */\n  positionFixed: false,\n\n  /**\n   * Whether events (resize, scroll) are initially enabled.\n   * @prop {Boolean} eventsEnabled=true\n   */\n  eventsEnabled: true,\n\n  /**\n   * Set to true if you want to automatically remove the popper when\n   * you call the `destroy` method.\n   * @prop {Boolean} removeOnDestroy=false\n   */\n  removeOnDestroy: false,\n\n  /**\n   * Callback called when the popper is created.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onCreate}\n   */\n  onCreate: function onCreate() {},\n\n  /**\n   * Callback called when the popper is updated. This callback is not called\n   * on the initialization/creation of the popper, but only on subsequent\n   * updates.<br />\n   * By default, it is set to no-op.<br />\n   * Access Popper.js instance with `data.instance`.\n   * @prop {onUpdate}\n   */\n  onUpdate: function onUpdate() {},\n\n  /**\n   * List of modifiers used to modify the offsets before they are applied to the popper.\n   * They provide most of the functionalities of Popper.js.\n   * @prop {modifiers}\n   */\n  modifiers: modifiers\n};\n\n/**\n * @callback onCreate\n * @param {dataObject} data\n */\n\n/**\n * @callback onUpdate\n * @param {dataObject} data\n */\n\n// Utils\n// Methods\nvar Popper = function () {\n  /**\n   * Creates a new Popper.js instance.\n   * @class Popper\n   * @param {Element|referenceObject} reference - The reference element used to position the popper\n   * @param {Element} popper - The HTML / XML element used as the popper\n   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n   * @return {Object} instance - The generated Popper.js instance\n   */\n  function Popper(reference, popper) {\n    var _this = this;\n\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    classCallCheck(this, Popper);\n\n    this.scheduleUpdate = function () {\n      return requestAnimationFrame(_this.update);\n    };\n\n    // make update() debounced, so that it only runs at most once-per-tick\n    this.update = debounce(this.update.bind(this));\n\n    // with {} we create a new object with the options inside it\n    this.options = _extends({}, Popper.Defaults, options);\n\n    // init state\n    this.state = {\n      isDestroyed: false,\n      isCreated: false,\n      scrollParents: []\n    };\n\n    // get reference and popper elements (allow jQuery wrappers)\n    this.reference = reference && reference.jquery ? reference[0] : reference;\n    this.popper = popper && popper.jquery ? popper[0] : popper;\n\n    // Deep merge modifiers options\n    this.options.modifiers = {};\n    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n    });\n\n    // Refactoring modifiers' list (Object => Array)\n    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n      return _extends({\n        name: name\n      }, _this.options.modifiers[name]);\n    })\n    // sort the modifiers by order\n    .sort(function (a, b) {\n      return a.order - b.order;\n    });\n\n    // modifiers have the ability to execute arbitrary code when Popper.js get inited\n    // such code is executed in the same order of its modifier\n    // they could add new properties to their options configuration\n    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n    this.modifiers.forEach(function (modifierOptions) {\n      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n      }\n    });\n\n    // fire the first update to position the popper in the right place\n    this.update();\n\n    var eventsEnabled = this.options.eventsEnabled;\n    if (eventsEnabled) {\n      // setup event listeners, they will take care of update the position in specific situations\n      this.enableEventListeners();\n    }\n\n    this.state.eventsEnabled = eventsEnabled;\n  }\n\n  // We can't use class properties because they don't get listed in the\n  // class prototype and break stuff like Sinon stubs\n\n\n  createClass(Popper, [{\n    key: 'update',\n    value: function update$$1() {\n      return update.call(this);\n    }\n  }, {\n    key: 'destroy',\n    value: function destroy$$1() {\n      return destroy.call(this);\n    }\n  }, {\n    key: 'enableEventListeners',\n    value: function enableEventListeners$$1() {\n      return enableEventListeners.call(this);\n    }\n  }, {\n    key: 'disableEventListeners',\n    value: function disableEventListeners$$1() {\n      return disableEventListeners.call(this);\n    }\n\n    /**\n     * Schedules an update. It will run on the next UI update available.\n     * @method scheduleUpdate\n     * @memberof Popper\n     */\n\n    /**\n     * Collection of utilities useful when writing custom modifiers.\n     * Starting from version 1.7, this method is available only if you\n     * include `popper-utils.js` before `popper.js`.\n     *\n     * **DEPRECATION**: This way to access PopperUtils is deprecated\n     * and will be removed in v2! Use the PopperUtils module directly instead.\n     * Due to the high instability of the methods contained in Utils, we can't\n     * guarantee them to follow semver. Use them at your own risk!\n     * @static\n     * @private\n     * @type {Object}\n     * @deprecated since version 1.8\n     * @member Utils\n     * @memberof Popper\n     */\n\n  }]);\n  return Popper;\n}();\n\n/**\n * The `referenceObject` is an object that provides an interface compatible with Popper.js\n * and lets you use it as replacement of a real DOM node.<br />\n * You can use this method to position a popper relatively to a set of coordinates\n * in case you don't have a DOM node to use as reference.\n *\n * ```\n * new Popper(referenceObject, popperNode);\n * ```\n *\n * NB: This feature isn't supported in Internet Explorer 10.\n * @name referenceObject\n * @property {Function} data.getBoundingClientRect\n * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n * @property {number} data.clientWidth\n * An ES6 getter that will return the width of the virtual reference element.\n * @property {number} data.clientHeight\n * An ES6 getter that will return the height of the virtual reference element.\n */\n\nPopper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;\nPopper.placements = placements;\nPopper.Defaults = Defaults;\n\nexports.default = Popper;\n//# sourceMappingURL=popper.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcG9wcGVyLmpzL2Rpc3QvZXNtL3BvcHBlci5qcz9mMGJkIl0sIm5hbWVzIjpbImlzQnJvd3NlciIsIndpbmRvdyIsImRvY3VtZW50IiwibmF2aWdhdG9yIiwidGltZW91dER1cmF0aW9uIiwibG9uZ2VyVGltZW91dEJyb3dzZXJzIiwiaSIsImxlbmd0aCIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJtaWNyb3Rhc2tEZWJvdW5jZSIsImZuIiwiY2FsbGVkIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwidGFza0RlYm91bmNlIiwic2NoZWR1bGVkIiwic2V0VGltZW91dCIsInN1cHBvcnRzTWljcm9UYXNrcyIsImRlYm91bmNlIiwiaXNGdW5jdGlvbiIsImZ1bmN0aW9uVG9DaGVjayIsImdldFR5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkiLCJlbGVtZW50IiwicHJvcGVydHkiLCJub2RlVHlwZSIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImNzcyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQYXJlbnROb2RlIiwibm9kZU5hbWUiLCJwYXJlbnROb2RlIiwiaG9zdCIsImdldFNjcm9sbFBhcmVudCIsImJvZHkiLCJfZ2V0U3R5bGVDb21wdXRlZFByb3AiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsInRlc3QiLCJnZXRSZWZlcmVuY2VOb2RlIiwicmVmZXJlbmNlIiwicmVmZXJlbmNlTm9kZSIsImlzSUUxMSIsIk1TSW5wdXRNZXRob2RDb250ZXh0IiwiZG9jdW1lbnRNb2RlIiwiaXNJRTEwIiwiaXNJRSIsInZlcnNpb24iLCJnZXRPZmZzZXRQYXJlbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJub09mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsIm5leHRFbGVtZW50U2libGluZyIsImlzT2Zmc2V0Q29udGFpbmVyIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJnZXRSb290Iiwibm9kZSIsImZpbmRDb21tb25PZmZzZXRQYXJlbnQiLCJlbGVtZW50MSIsImVsZW1lbnQyIiwib3JkZXIiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIk5vZGUiLCJET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkciLCJzdGFydCIsImVuZCIsInJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJzZXRTdGFydCIsInNldEVuZCIsImNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIiwiY29udGFpbnMiLCJlbGVtZW50MXJvb3QiLCJnZXRTY3JvbGwiLCJzaWRlIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwidXBwZXJTaWRlIiwiaHRtbCIsInNjcm9sbGluZ0VsZW1lbnQiLCJpbmNsdWRlU2Nyb2xsIiwicmVjdCIsInN1YnRyYWN0Iiwic2Nyb2xsVG9wIiwic2Nyb2xsTGVmdCIsIm1vZGlmaWVyIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiZ2V0Qm9yZGVyc1NpemUiLCJzdHlsZXMiLCJheGlzIiwic2lkZUEiLCJzaWRlQiIsInBhcnNlRmxvYXQiLCJnZXRTaXplIiwiY29tcHV0ZWRTdHlsZSIsIk1hdGgiLCJtYXgiLCJwYXJzZUludCIsImdldFdpbmRvd1NpemVzIiwiaGVpZ2h0Iiwid2lkdGgiLCJjbGFzc0NhbGxDaGVjayIsImluc3RhbmNlIiwiQ29uc3RydWN0b3IiLCJUeXBlRXJyb3IiLCJjcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImtleSIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsInByb3RvdHlwZSIsIm9iaiIsInZhbHVlIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJzb3VyY2UiLCJoYXNPd25Qcm9wZXJ0eSIsImdldENsaWVudFJlY3QiLCJvZmZzZXRzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiZSIsInJlc3VsdCIsInNpemVzIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJob3JpelNjcm9sbGJhciIsIm9mZnNldFdpZHRoIiwidmVydFNjcm9sbGJhciIsIm9mZnNldEhlaWdodCIsImdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZSIsImNoaWxkcmVuIiwicGFyZW50IiwiZml4ZWRQb3NpdGlvbiIsImlzSFRNTCIsImNoaWxkcmVuUmVjdCIsInBhcmVudFJlY3QiLCJzY3JvbGxQYXJlbnQiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsIm1hcmdpblRvcCIsIm1hcmdpbkxlZnQiLCJnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUiLCJleGNsdWRlU2Nyb2xsIiwicmVsYXRpdmVPZmZzZXQiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJvZmZzZXQiLCJpc0ZpeGVkIiwiZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudCIsInBhcmVudEVsZW1lbnQiLCJlbCIsImdldEJvdW5kYXJpZXMiLCJwb3BwZXIiLCJwYWRkaW5nIiwiYm91bmRhcmllc0VsZW1lbnQiLCJib3VuZGFyaWVzIiwiYm91bmRhcmllc05vZGUiLCJfZ2V0V2luZG93U2l6ZXMiLCJpc1BhZGRpbmdOdW1iZXIiLCJnZXRBcmVhIiwiX3JlZiIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwicGxhY2VtZW50IiwicmVmUmVjdCIsInJlY3RzIiwic29ydGVkQXJlYXMiLCJrZXlzIiwibWFwIiwiYXJlYSIsInNvcnQiLCJhIiwiYiIsImZpbHRlcmVkQXJlYXMiLCJmaWx0ZXIiLCJfcmVmMiIsImNvbXB1dGVkUGxhY2VtZW50IiwidmFyaWF0aW9uIiwic3BsaXQiLCJnZXRSZWZlcmVuY2VPZmZzZXRzIiwic3RhdGUiLCJjb21tb25PZmZzZXRQYXJlbnQiLCJnZXRPdXRlclNpemVzIiwieCIsIm1hcmdpbkJvdHRvbSIsInkiLCJtYXJnaW5SaWdodCIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiaGFzaCIsInJlcGxhY2UiLCJtYXRjaGVkIiwiZ2V0UG9wcGVyT2Zmc2V0cyIsInJlZmVyZW5jZU9mZnNldHMiLCJwb3BwZXJSZWN0IiwicG9wcGVyT2Zmc2V0cyIsImlzSG9yaXoiLCJtYWluU2lkZSIsInNlY29uZGFyeVNpZGUiLCJtZWFzdXJlbWVudCIsInNlY29uZGFyeU1lYXN1cmVtZW50IiwiZmluZCIsImFyciIsImNoZWNrIiwiQXJyYXkiLCJmaW5kSW5kZXgiLCJwcm9wIiwiY3VyIiwibWF0Y2giLCJydW5Nb2RpZmllcnMiLCJtb2RpZmllcnMiLCJkYXRhIiwiZW5kcyIsIm1vZGlmaWVyc1RvUnVuIiwic2xpY2UiLCJmb3JFYWNoIiwiY29uc29sZSIsIndhcm4iLCJlbmFibGVkIiwidXBkYXRlIiwiaXNEZXN0cm95ZWQiLCJhcnJvd1N0eWxlcyIsImF0dHJpYnV0ZXMiLCJmbGlwcGVkIiwib3B0aW9ucyIsInBvc2l0aW9uRml4ZWQiLCJmbGlwIiwib3JpZ2luYWxQbGFjZW1lbnQiLCJwb3NpdGlvbiIsImlzQ3JlYXRlZCIsIm9uQ3JlYXRlIiwib25VcGRhdGUiLCJpc01vZGlmaWVyRW5hYmxlZCIsIm1vZGlmaWVyTmFtZSIsInNvbWUiLCJuYW1lIiwiZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lIiwicHJlZml4ZXMiLCJ1cHBlclByb3AiLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInByZWZpeCIsInRvQ2hlY2siLCJzdHlsZSIsImRlc3Ryb3kiLCJyZW1vdmVBdHRyaWJ1dGUiLCJ3aWxsQ2hhbmdlIiwiZGlzYWJsZUV2ZW50TGlzdGVuZXJzIiwicmVtb3ZlT25EZXN0cm95IiwicmVtb3ZlQ2hpbGQiLCJnZXRXaW5kb3ciLCJhdHRhY2hUb1Njcm9sbFBhcmVudHMiLCJldmVudCIsImNhbGxiYWNrIiwic2Nyb2xsUGFyZW50cyIsImlzQm9keSIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwicHVzaCIsInNldHVwRXZlbnRMaXN0ZW5lcnMiLCJ1cGRhdGVCb3VuZCIsInNjcm9sbEVsZW1lbnQiLCJldmVudHNFbmFibGVkIiwiZW5hYmxlRXZlbnRMaXN0ZW5lcnMiLCJzY2hlZHVsZVVwZGF0ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaXNOdW1lcmljIiwibiIsImlzTmFOIiwiaXNGaW5pdGUiLCJzZXRTdHlsZXMiLCJ1bml0Iiwic2V0QXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsImFwcGx5U3R5bGUiLCJhcnJvd0VsZW1lbnQiLCJhcHBseVN0eWxlT25Mb2FkIiwibW9kaWZpZXJPcHRpb25zIiwiZ2V0Um91bmRlZE9mZnNldHMiLCJzaG91bGRSb3VuZCIsIl9kYXRhJG9mZnNldHMiLCJyb3VuZCIsImZsb29yIiwibm9Sb3VuZCIsInYiLCJyZWZlcmVuY2VXaWR0aCIsInBvcHBlcldpZHRoIiwiaXNWZXJ0aWNhbCIsImlzVmFyaWF0aW9uIiwic2FtZVdpZHRoUGFyaXR5IiwiYm90aE9kZFdpZHRoIiwiaG9yaXpvbnRhbFRvSW50ZWdlciIsInZlcnRpY2FsVG9JbnRlZ2VyIiwiaXNGaXJlZm94IiwiY29tcHV0ZVN0eWxlIiwibGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIiwiZ3B1QWNjZWxlcmF0aW9uIiwib2Zmc2V0UGFyZW50UmVjdCIsImRldmljZVBpeGVsUmF0aW8iLCJwcmVmaXhlZFByb3BlcnR5IiwiaW52ZXJ0VG9wIiwiaW52ZXJ0TGVmdCIsImFycm93IiwiaXNNb2RpZmllclJlcXVpcmVkIiwicmVxdWVzdGluZ05hbWUiLCJyZXF1ZXN0ZWROYW1lIiwicmVxdWVzdGluZyIsImlzUmVxdWlyZWQiLCJfcmVxdWVzdGluZyIsInJlcXVlc3RlZCIsIl9kYXRhJG9mZnNldHMkYXJyb3ciLCJxdWVyeVNlbGVjdG9yIiwibGVuIiwic2lkZUNhcGl0YWxpemVkIiwidG9Mb3dlckNhc2UiLCJhbHRTaWRlIiwib3BTaWRlIiwiYXJyb3dFbGVtZW50U2l6ZSIsImNlbnRlciIsInBvcHBlck1hcmdpblNpZGUiLCJwb3BwZXJCb3JkZXJTaWRlIiwic2lkZVZhbHVlIiwibWluIiwiZ2V0T3Bwb3NpdGVWYXJpYXRpb24iLCJwbGFjZW1lbnRzIiwidmFsaWRQbGFjZW1lbnRzIiwiY2xvY2t3aXNlIiwiY291bnRlciIsImluZGV4IiwiY29uY2F0IiwicmV2ZXJzZSIsIkJFSEFWSU9SUyIsIkZMSVAiLCJDTE9DS1dJU0UiLCJDT1VOVEVSQ0xPQ0tXSVNFIiwicGxhY2VtZW50T3Bwb3NpdGUiLCJmbGlwT3JkZXIiLCJiZWhhdmlvciIsInN0ZXAiLCJyZWZPZmZzZXRzIiwib3ZlcmxhcHNSZWYiLCJvdmVyZmxvd3NMZWZ0Iiwib3ZlcmZsb3dzUmlnaHQiLCJvdmVyZmxvd3NUb3AiLCJvdmVyZmxvd3NCb3R0b20iLCJvdmVyZmxvd3NCb3VuZGFyaWVzIiwiZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIiwiZmxpcFZhcmlhdGlvbnMiLCJmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50IiwiZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQiLCJmbGlwcGVkVmFyaWF0aW9uIiwia2VlcFRvZ2V0aGVyIiwidG9WYWx1ZSIsInN0ciIsInNpemUiLCJwYXJzZU9mZnNldCIsImJhc2VQbGFjZW1lbnQiLCJ1c2VIZWlnaHQiLCJmcmFnbWVudHMiLCJmcmFnIiwidHJpbSIsImRpdmlkZXIiLCJzZWFyY2giLCJzcGxpdFJlZ2V4Iiwib3BzIiwib3AiLCJtZXJnZVdpdGhQcmV2aW91cyIsInJlZHVjZSIsImluZGV4MiIsInByZXZlbnRPdmVyZmxvdyIsInRyYW5zZm9ybVByb3AiLCJwb3BwZXJTdHlsZXMiLCJ0cmFuc2Zvcm0iLCJwcmlvcml0eSIsInByaW1hcnkiLCJlc2NhcGVXaXRoUmVmZXJlbmNlIiwic2Vjb25kYXJ5Iiwic2hpZnQiLCJzaGlmdHZhcmlhdGlvbiIsInNoaWZ0T2Zmc2V0cyIsImhpZGUiLCJib3VuZCIsImlubmVyIiwic3VidHJhY3RMZW5ndGgiLCJvbkxvYWQiLCJEZWZhdWx0cyIsIlBvcHBlciIsIl90aGlzIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYmluZCIsImpxdWVyeSIsInVwZGF0ZSQkMSIsImRlc3Ryb3kkJDEiLCJlbmFibGVFdmVudExpc3RlbmVycyQkMSIsImRpc2FibGVFdmVudExpc3RlbmVycyQkMSIsIlV0aWxzIiwiZ2xvYmFsIiwiUG9wcGVyVXRpbHMiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXdCQSxJQUFJQSxZQUFZLE9BQU9DLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUMsT0FBT0MsUUFBUCxLQUFvQixXQUFyRCxJQUFvRSxPQUFPQyxTQUFQLEtBQXFCLFdBQXpHOztBQUVBLElBQUlDLGtCQUFrQixZQUFZO0FBQ2hDLE1BQUlDLHdCQUF3QixDQUFDLE1BQUQsRUFBUyxTQUFULEVBQW9CLFNBQXBCLENBQTVCO0FBQ0EsT0FBSyxJQUFJQyxJQUFJLENBQWIsRUFBZ0JBLElBQUlELHNCQUFzQkUsTUFBMUMsRUFBa0RELEtBQUssQ0FBdkQsRUFBMEQ7QUFDeEQsUUFBSU4sYUFBYUcsVUFBVUssU0FBVixDQUFvQkMsT0FBcEIsQ0FBNEJKLHNCQUFzQkMsQ0FBdEIsQ0FBNUIsS0FBeUQsQ0FBMUUsRUFBNkU7QUFDM0UsYUFBTyxDQUFQO0FBQ0Q7QUFDRjtBQUNELFNBQU8sQ0FBUDtBQUNELENBUnFCLEVBQXRCOztBQVVBLFNBQVNJLGlCQUFULENBQTJCQyxFQUEzQixFQUErQjtBQUM3QixNQUFJQyxTQUFTLEtBQWI7QUFDQSxTQUFPLFlBQVk7QUFDakIsUUFBSUEsTUFBSixFQUFZO0FBQ1Y7QUFDRDtBQUNEQSxhQUFTLElBQVQ7QUFDQVgsV0FBT1ksT0FBUCxDQUFlQyxPQUFmLEdBQXlCQyxJQUF6QixDQUE4QixZQUFZO0FBQ3hDSCxlQUFTLEtBQVQ7QUFDQUQ7QUFDRCxLQUhEO0FBSUQsR0FURDtBQVVEOztBQUVELFNBQVNLLFlBQVQsQ0FBc0JMLEVBQXRCLEVBQTBCO0FBQ3hCLE1BQUlNLFlBQVks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bS9wb3BwZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE2LjFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgRmVkZXJpY28gWml2b2xvIGFuZCBjb250cmlidXRvcnNcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW4gYWxsXG4gKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG52YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJztcblxudmFyIHRpbWVvdXREdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGxvbmdlclRpbWVvdXRCcm93c2VycyA9IFsnRWRnZScsICdUcmlkZW50JywgJ0ZpcmVmb3gnXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb25nZXJUaW1lb3V0QnJvd3NlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn0oKTtcblxuZnVuY3Rpb24gbWljcm90YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICB3aW5kb3cuUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBjYWxsZWQgPSBmYWxzZTtcbiAgICAgIGZuKCk7XG4gICAgfSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRhc2tEZWJvdW5jZShmbikge1xuICB2YXIgc2NoZWR1bGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzY2hlZHVsZWQpIHtcbiAgICAgIHNjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIGZuKCk7XG4gICAgICB9LCB0aW1lb3V0RHVyYXRpb24pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHN1cHBvcnRzTWljcm9UYXNrcyA9IGlzQnJvd3NlciAmJiB3aW5kb3cuUHJvbWlzZTtcblxuLyoqXG4qIENyZWF0ZSBhIGRlYm91bmNlZCB2ZXJzaW9uIG9mIGEgbWV0aG9kLCB0aGF0J3MgYXN5bmNocm9ub3VzbHkgZGVmZXJyZWRcbiogYnV0IGNhbGxlZCBpbiB0aGUgbWluaW11bSB0aW1lIHBvc3NpYmxlLlxuKlxuKiBAbWV0aG9kXG4qIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiogQGFyZ3VtZW50IHtGdW5jdGlvbn0gZm5cbiogQHJldHVybnMge0Z1bmN0aW9ufVxuKi9cbnZhciBkZWJvdW5jZSA9IHN1cHBvcnRzTWljcm9UYXNrcyA/IG1pY3JvdGFza0RlYm91bmNlIDogdGFza0RlYm91bmNlO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FueX0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG86IGlzIGEgZnVuY3Rpb24/XG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIHZhciBnZXRUeXBlID0ge307XG4gIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogR2V0IENTUyBjb21wdXRlZCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eVxuICovXG5mdW5jdGlvbiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgaWYgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIGNzcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICByZXR1cm4gcHJvcGVydHkgPyBjc3NbcHJvcGVydHldIDogY3NzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudE5vZGUgb3IgdGhlIGhvc3Qgb2YgdGhlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbGluZyBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICBpZiAoLyhhdXRvfHNjcm9sbHxvdmVybGF5KS8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCkpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVmZXJlbmNlIG5vZGUgb2YgdGhlIHJlZmVyZW5jZSBvYmplY3QsIG9yIHRoZSByZWZlcmVuY2Ugb2JqZWN0IGl0c2VsZi5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3R9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSB7XG4gIHJldHVybiByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgPyByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA6IHJlZmVyZW5jZTtcbn1cblxudmFyIGlzSUUxMSA9IGlzQnJvd3NlciAmJiAhISh3aW5kb3cuTVNJbnB1dE1ldGhvZENvbnRleHQgJiYgZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTtcbnZhciBpc0lFMTAgPSBpc0Jyb3dzZXIgJiYgL01TSUUgMTAvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtOdW1iZXJ9IHZlcnNpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSBpc0lFXG4gKi9cbmZ1bmN0aW9uIGlzSUUodmVyc2lvbikge1xuICBpZiAodmVyc2lvbiA9PT0gMTEpIHtcbiAgICByZXR1cm4gaXNJRTExO1xuICB9XG4gIGlmICh2ZXJzaW9uID09PSAxMCkge1xuICAgIHJldHVybiBpc0lFMTA7XG4gIH1cbiAgcmV0dXJuIGlzSUUxMSB8fCBpc0lFMTA7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb2Zmc2V0IHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgdmFyIG5vT2Zmc2V0UGFyZW50ID0gaXNJRSgxMCkgPyBkb2N1bWVudC5ib2R5IDogbnVsbDtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQgfHwgbnVsbDtcbiAgLy8gU2tpcCBoaWRkZW4gZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhbiBvZmZzZXRQYXJlbnRcbiAgd2hpbGUgKG9mZnNldFBhcmVudCA9PT0gbm9PZmZzZXRQYXJlbnQgJiYgZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSAoZWxlbWVudCA9IGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKS5vZmZzZXRQYXJlbnQ7XG4gIH1cblxuICB2YXIgbm9kZU5hbWUgPSBvZmZzZXRQYXJlbnQgJiYgb2Zmc2V0UGFyZW50Lm5vZGVOYW1lO1xuXG4gIGlmICghbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gLm9mZnNldFBhcmVudCB3aWxsIHJldHVybiB0aGUgY2xvc2VzdCBUSCwgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1RIJywgJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICB2YXIgb3JkZXIgPSBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICB2YXIgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcblxuICBpZiAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICB2YXIgc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3RvcCc7XG5cbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCkge1xuICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXSkgKyBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVCICsgJ1dpZHRoJ10pO1xufVxuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGJvZHlbJ29mZnNldCcgKyBheGlzXSwgYm9keVsnc2Nyb2xsJyArIGF4aXNdLCBodG1sWydjbGllbnQnICsgYXhpc10sIGh0bWxbJ29mZnNldCcgKyBheGlzXSwgaHRtbFsnc2Nyb2xsJyArIGF4aXNdLCBpc0lFKDEwKSA/IHBhcnNlSW50KGh0bWxbJ29mZnNldCcgKyBheGlzXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ1RvcCcgOiAnTGVmdCcpXSkgKyBwYXJzZUludChjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ0JvdHRvbScgOiAnUmlnaHQnKV0pIDogMCk7XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1NpemVzKGRvY3VtZW50KSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNJRSgxMCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZShodG1sKTtcblxuICByZXR1cm4ge1xuICAgIGhlaWdodDogZ2V0U2l6ZSgnSGVpZ2h0JywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSksXG4gICAgd2lkdGg6IGdldFNpemUoJ1dpZHRoJywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSlcbiAgfTtcbn1cblxudmFyIGNsYXNzQ2FsbENoZWNrID0gZnVuY3Rpb24gKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn07XG5cbnZhciBjcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEdpdmVuIGVsZW1lbnQgb2Zmc2V0cywgZ2VuZXJhdGUgYW4gb3V0cHV0IHNpbWlsYXIgdG8gZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gb2Zmc2V0c1xuICogQHJldHVybnMge09iamVjdH0gQ2xpZW50UmVjdCBsaWtlIG91dHB1dFxuICovXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KG9mZnNldHMpIHtcbiAgcmV0dXJuIF9leHRlbmRzKHt9LCBvZmZzZXRzLCB7XG4gICAgcmlnaHQ6IG9mZnNldHMubGVmdCArIG9mZnNldHMud2lkdGgsXG4gICAgYm90dG9tOiBvZmZzZXRzLnRvcCArIG9mZnNldHMuaGVpZ2h0XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0ge307XG5cbiAgLy8gSUUxMCAxMCBGSVg6IFBsZWFzZSwgZG9uJ3QgYXNrLCB0aGUgZWxlbWVudCBpc24ndFxuICAvLyBjb25zaWRlcmVkIGluIERPTSBpbiBzb21lIGNpcmN1bXN0YW5jZXMuLi5cbiAgLy8gVGhpcyBpc24ndCByZXByb2R1Y2libGUgaW4gSUUxMCBjb21wYXRpYmlsaXR5IG1vZGUgb2YgSUUxMVxuICB0cnkge1xuICAgIGlmIChpc0lFKDEwKSkge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gICAgICByZWN0LnRvcCArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdDtcbiAgICAgIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSB7XG4gICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3QudG9wXG4gIH07XG5cbiAgLy8gc3VidHJhY3Qgc2Nyb2xsYmFyIHNpemUgZnJvbSBzaXplc1xuICB2YXIgc2l6ZXMgPSBlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcgPyBnZXRXaW5kb3dTaXplcyhlbGVtZW50Lm93bmVyRG9jdW1lbnQpIDoge307XG4gIHZhciB3aWR0aCA9IHNpemVzLndpZHRoIHx8IGVsZW1lbnQuY2xpZW50V2lkdGggfHwgcmVzdWx0LndpZHRoO1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5oZWlnaHQ7XG5cbiAgdmFyIGhvcml6U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRXaWR0aCAtIHdpZHRoO1xuICB2YXIgdmVydFNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0IC0gaGVpZ2h0O1xuXG4gIC8vIGlmIGFuIGh5cG90aGV0aWNhbCBzY3JvbGxiYXIgaXMgZGV0ZWN0ZWQsIHdlIG11c3QgYmUgc3VyZSBpdCdzIG5vdCBhIGBib3JkZXJgXG4gIC8vIHdlIG1ha2UgdGhpcyBjaGVjayBjb25kaXRpb25hbCBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICBpZiAoaG9yaXpTY3JvbGxiYXIgfHwgdmVydFNjcm9sbGJhcikge1xuICAgIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCk7XG4gICAgaG9yaXpTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneCcpO1xuICAgIHZlcnRTY3JvbGxiYXIgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAneScpO1xuXG4gICAgcmVzdWx0LndpZHRoIC09IGhvcml6U2Nyb2xsYmFyO1xuICAgIHJlc3VsdC5oZWlnaHQgLT0gdmVydFNjcm9sbGJhcjtcbiAgfVxuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KHJlc3VsdCk7XG59XG5cbmZ1bmN0aW9uIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShjaGlsZHJlbiwgcGFyZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgaXNJRTEwID0gaXNJRSgxMCk7XG4gIHZhciBpc0hUTUwgPSBwYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJztcbiAgdmFyIGNoaWxkcmVuUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChjaGlsZHJlbik7XG4gIHZhciBwYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHBhcmVudCk7XG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoY2hpbGRyZW4pO1xuXG4gIHZhciBzdHlsZXMgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50KTtcbiAgdmFyIGJvcmRlclRvcFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyVG9wV2lkdGgpO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoKTtcblxuICAvLyBJbiBjYXNlcyB3aGVyZSB0aGUgcGFyZW50IGlzIGZpeGVkLCB3ZSBtdXN0IGlnbm9yZSBuZWdhdGl2ZSBzY3JvbGwgaW4gb2Zmc2V0IGNhbGNcbiAgaWYgKGZpeGVkUG9zaXRpb24gJiYgaXNIVE1MKSB7XG4gICAgcGFyZW50UmVjdC50b3AgPSBNYXRoLm1heChwYXJlbnRSZWN0LnRvcCwgMCk7XG4gICAgcGFyZW50UmVjdC5sZWZ0ID0gTWF0aC5tYXgocGFyZW50UmVjdC5sZWZ0LCAwKTtcbiAgfVxuICB2YXIgb2Zmc2V0cyA9IGdldENsaWVudFJlY3Qoe1xuICAgIHRvcDogY2hpbGRyZW5SZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wIC0gYm9yZGVyVG9wV2lkdGgsXG4gICAgbGVmdDogY2hpbGRyZW5SZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgLSBib3JkZXJMZWZ0V2lkdGgsXG4gICAgd2lkdGg6IGNoaWxkcmVuUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IGNoaWxkcmVuUmVjdC5oZWlnaHRcbiAgfSk7XG4gIG9mZnNldHMubWFyZ2luVG9wID0gMDtcbiAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gMDtcblxuICAvLyBTdWJ0cmFjdCBtYXJnaW5zIG9mIGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGl0J3MgYmVpbmcgdXNlZCBhcyBwYXJlbnRcbiAgLy8gd2UgZG8gdGhpcyBvbmx5IG9uIEhUTUwgYmVjYXVzZSBpdCdzIHRoZSBvbmx5IGVsZW1lbnQgdGhhdCBiZWhhdmVzXG4gIC8vIGRpZmZlcmVudGx5IHdoZW4gbWFyZ2lucyBhcmUgYXBwbGllZCB0byBpdC4gVGhlIG1hcmdpbnMgYXJlIGluY2x1ZGVkIGluXG4gIC8vIHRoZSBib3ggb2YgdGhlIGRvY3VtZW50RWxlbWVudCwgaW4gdGhlIG90aGVyIGNhc2VzIG5vdC5cbiAgaWYgKCFpc0lFMTAgJiYgaXNIVE1MKSB7XG4gICAgdmFyIG1hcmdpblRvcCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCk7XG4gICAgdmFyIG1hcmdpbkxlZnQgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0KTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwICYmICFmaXhlZFBvc2l0aW9uID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGV4Y2x1ZGVTY3JvbGwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIHJlbGF0aXZlT2Zmc2V0ID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGVsZW1lbnQsIGh0bWwpO1xuICB2YXIgd2lkdGggPSBNYXRoLm1heChodG1sLmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgdmFyIGhlaWdodCA9IE1hdGgubWF4KGh0bWwuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG5cbiAgdmFyIHNjcm9sbFRvcCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwpIDogMDtcbiAgdmFyIHNjcm9sbExlZnQgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sLCAnbGVmdCcpIDogMDtcblxuICB2YXIgb2Zmc2V0ID0ge1xuICAgIHRvcDogc2Nyb2xsVG9wIC0gcmVsYXRpdmVPZmZzZXQudG9wICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luVG9wLFxuICAgIGxlZnQ6IHNjcm9sbExlZnQgLSByZWxhdGl2ZU9mZnNldC5sZWZ0ICsgcmVsYXRpdmVPZmZzZXQubWFyZ2luTGVmdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChvZmZzZXQpO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0byBcImlzRml4ZWQ/XCJcbiAqL1xuZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCAncG9zaXRpb24nKSA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwYXJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpeGVkKHBhcmVudE5vZGUpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBwYXJlbnQgb2YgYW4gZWxlbWVudCB0aGF0IGhhcyBhIHRyYW5zZm9ybWVkIHByb3BlcnR5IGRlZmluZWRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IGZpcnN0IHRyYW5zZm9ybWVkIHBhcmVudCBvciBkb2N1bWVudEVsZW1lbnRcbiAqL1xuXG5mdW5jdGlvbiBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5wYXJlbnRFbGVtZW50IHx8IGlzSUUoKSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgdmFyIGVsID0gZWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICB3aGlsZSAoZWwgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsLCAndHJhbnNmb3JtJykgPT09ICdub25lJykge1xuICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWwgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xufVxuXG4vKipcbiAqIENvbXB1dGVkIHRoZSBib3VuZGFyaWVzIGxpbWl0cyBhbmQgcmV0dXJuIHRoZW1cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZ1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQgLSBFbGVtZW50IHVzZWQgdG8gZGVmaW5lIHRoZSBib3VuZGFyaWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGZpeGVkUG9zaXRpb24gLSBJcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICovXG5mdW5jdGlvbiBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcblxuICB2YXIgYm91bmRhcmllcyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG5cbiAgLy8gSGFuZGxlIHZpZXdwb3J0IGNhc2VcbiAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgYm91bmRhcmllcyA9IGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuICB9IGVsc2Uge1xuICAgIC8vIEhhbmRsZSBvdGhlciBjYXNlcyBiYXNlZCBvbiBET00gZWxlbWVudCB1c2VkIGFzIGJvdW5kYXJpZXNcbiAgICB2YXIgYm91bmRhcmllc05vZGUgPSB2b2lkIDA7XG4gICAgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnc2Nyb2xsUGFyZW50Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShyZWZlcmVuY2UpKTtcbiAgICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd3aW5kb3cnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBib3VuZGFyaWVzRWxlbWVudDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0cyA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShib3VuZGFyaWVzTm9kZSwgb2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcblxuICAgIC8vIEluIGNhc2Ugb2YgSFRNTCwgd2UgbmVlZCBhIGRpZmZlcmVudCBjb21wdXRhdGlvblxuICAgIGlmIChib3VuZGFyaWVzTm9kZS5ub2RlTmFtZSA9PT0gJ0hUTUwnICYmICFpc0ZpeGVkKG9mZnNldFBhcmVudCkpIHtcbiAgICAgIHZhciBfZ2V0V2luZG93U2l6ZXMgPSBnZXRXaW5kb3dTaXplcyhwb3BwZXIub3duZXJEb2N1bWVudCksXG4gICAgICAgICAgaGVpZ2h0ID0gX2dldFdpbmRvd1NpemVzLmhlaWdodCxcbiAgICAgICAgICB3aWR0aCA9IF9nZXRXaW5kb3dTaXplcy53aWR0aDtcblxuICAgICAgYm91bmRhcmllcy50b3AgKz0gb2Zmc2V0cy50b3AgLSBvZmZzZXRzLm1hcmdpblRvcDtcbiAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gaGVpZ2h0ICsgb2Zmc2V0cy50b3A7XG4gICAgICBib3VuZGFyaWVzLmxlZnQgKz0gb2Zmc2V0cy5sZWZ0IC0gb2Zmc2V0cy5tYXJnaW5MZWZ0O1xuICAgICAgYm91bmRhcmllcy5yaWdodCA9IHdpZHRoICsgb2Zmc2V0cy5sZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBmb3IgYWxsIHRoZSBvdGhlciBET00gZWxlbWVudHMsIHRoaXMgb25lIGlzIGdvb2RcbiAgICAgIGJvdW5kYXJpZXMgPSBvZmZzZXRzO1xuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBwYWRkaW5nc1xuICBwYWRkaW5nID0gcGFkZGluZyB8fCAwO1xuICB2YXIgaXNQYWRkaW5nTnVtYmVyID0gdHlwZW9mIHBhZGRpbmcgPT09ICdudW1iZXInO1xuICBib3VuZGFyaWVzLmxlZnQgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcubGVmdCB8fCAwO1xuICBib3VuZGFyaWVzLnRvcCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy50b3AgfHwgMDtcbiAgYm91bmRhcmllcy5yaWdodCAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5yaWdodCB8fCAwO1xuICBib3VuZGFyaWVzLmJvdHRvbSAtPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5ib3R0b20gfHwgMDtcblxuICByZXR1cm4gYm91bmRhcmllcztcbn1cblxuZnVuY3Rpb24gZ2V0QXJlYShfcmVmKSB7XG4gIHZhciB3aWR0aCA9IF9yZWYud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfcmVmLmhlaWdodDtcblxuICByZXR1cm4gd2lkdGggKiBoZWlnaHQ7XG59XG5cbi8qKlxuICogVXRpbGl0eSB1c2VkIHRvIHRyYW5zZm9ybSB0aGUgYGF1dG9gIHBsYWNlbWVudCB0byB0aGUgcGxhY2VtZW50IHdpdGggbW9yZVxuICogYXZhaWxhYmxlIHNwYWNlLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQocGxhY2VtZW50LCByZWZSZWN0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIHBhZGRpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDA7XG5cbiAgaWYgKHBsYWNlbWVudC5pbmRleE9mKCdhdXRvJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudDtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpO1xuXG4gIHZhciByZWN0cyA9IHtcbiAgICB0b3A6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiByZWZSZWN0LnRvcCAtIGJvdW5kYXJpZXMudG9wXG4gICAgfSxcbiAgICByaWdodDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMucmlnaHQgLSByZWZSZWN0LnJpZ2h0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH0sXG4gICAgYm90dG9tOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5ib3R0b20gLSByZWZSZWN0LmJvdHRvbVxuICAgIH0sXG4gICAgbGVmdDoge1xuICAgICAgd2lkdGg6IHJlZlJlY3QubGVmdCAtIGJvdW5kYXJpZXMubGVmdCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNvcnRlZEFyZWFzID0gT2JqZWN0LmtleXMocmVjdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgcmVjdHNba2V5XSwge1xuICAgICAgYXJlYTogZ2V0QXJlYShyZWN0c1trZXldKVxuICAgIH0pO1xuICB9KS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuYXJlYSAtIGEuYXJlYTtcbiAgfSk7XG5cbiAgdmFyIGZpbHRlcmVkQXJlYXMgPSBzb3J0ZWRBcmVhcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgdmFyIHdpZHRoID0gX3JlZjIud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF9yZWYyLmhlaWdodDtcbiAgICByZXR1cm4gd2lkdGggPj0gcG9wcGVyLmNsaWVudFdpZHRoICYmIGhlaWdodCA+PSBwb3BwZXIuY2xpZW50SGVpZ2h0O1xuICB9KTtcblxuICB2YXIgY29tcHV0ZWRQbGFjZW1lbnQgPSBmaWx0ZXJlZEFyZWFzLmxlbmd0aCA+IDAgPyBmaWx0ZXJlZEFyZWFzWzBdLmtleSA6IHNvcnRlZEFyZWFzWzBdLmtleTtcblxuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgcmV0dXJuIGNvbXB1dGVkUGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7RWxlbWVudH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7RWxlbWVudH0gZml4ZWRQb3NpdGlvbiAtIGlzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHZhciBjb21tb25PZmZzZXRQYXJlbnQgPSBmaXhlZFBvc2l0aW9uID8gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChwb3BwZXIpIDogZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIGdldFJlZmVyZW5jZU5vZGUocmVmZXJlbmNlKSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gIHZhciB4ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wIHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tIHx8IDApO1xuICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5SaWdodCB8fCAwKTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZChhcnIsIGNoZWNrKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgcmV0dXJuIGFyci5maW5kKGNoZWNrKTtcbiAgfVxuXG4gIC8vIHVzZSBgZmlsdGVyYCB0byBvYnRhaW4gdGhlIHNhbWUgYmVoYXZpb3Igb2YgYGZpbmRgXG4gIHJldHVybiBhcnIuZmlsdGVyKGNoZWNrKVswXTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgcHJvcCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kSW5kZXggaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZEluZGV4KSB7XG4gICAgcmV0dXJuIGFyci5maW5kSW5kZXgoZnVuY3Rpb24gKGN1cikge1xuICAgICAgcmV0dXJuIGN1cltwcm9wXSA9PT0gdmFsdWU7XG4gICAgfSk7XG4gIH1cblxuICAvLyB1c2UgYGZpbmRgICsgYGluZGV4T2ZgIGlmIGBmaW5kSW5kZXhgIGlzbid0IHN1cHBvcnRlZFxuICB2YXIgbWF0Y2ggPSBmaW5kKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4KG1vZGlmaWVycywgJ25hbWUnLCBlbmRzKSk7XG5cbiAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAobW9kaWZpZXJbJ2Z1bmN0aW9uJ10pIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgICBjb25zb2xlLndhcm4oJ2Btb2RpZmllci5mdW5jdGlvbmAgaXMgZGVwcmVjYXRlZCwgdXNlIGBtb2RpZmllci5mbmAhJyk7XG4gICAgfVxuICAgIHZhciBmbiA9IG1vZGlmaWVyWydmdW5jdGlvbiddIHx8IG1vZGlmaWVyLmZuOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIGlmIChtb2RpZmllci5lbmFibGVkICYmIGlzRnVuY3Rpb24oZm4pKSB7XG4gICAgICAvLyBBZGQgcHJvcGVydGllcyB0byBvZmZzZXRzIHRvIG1ha2UgdGhlbSBhIGNvbXBsZXRlIGNsaWVudFJlY3Qgb2JqZWN0XG4gICAgICAvLyB3ZSBkbyB0aGlzIGJlZm9yZSBlYWNoIG1vZGlmaWVyIHRvIG1ha2Ugc3VyZSB0aGUgcHJldmlvdXMgb25lIGRvZXNuJ3RcbiAgICAgIC8vIG1lc3Mgd2l0aCB0aGVzZSB2YWx1ZXNcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuICAgICAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSk7XG5cbiAgICAgIGRhdGEgPSBmbihkYXRhLCBtb2RpZmllcik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyLCBjb21wdXRpbmcgdGhlIG5ldyBvZmZzZXRzIGFuZCBhcHBseWluZ1xuICogdGhlIG5ldyBzdHlsZS48YnIgLz5cbiAqIFByZWZlciBgc2NoZWR1bGVVcGRhdGVgIG92ZXIgYHVwZGF0ZWAgYmVjYXVzZSBvZiBwZXJmb3JtYW5jZSByZWFzb25zLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiB1cGRhdGUoKSB7XG4gIC8vIGlmIHBvcHBlciBpcyBkZXN0cm95ZWQsIGRvbid0IHBlcmZvcm0gYW55IGZ1cnRoZXIgdXBkYXRlXG4gIGlmICh0aGlzLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRhdGEgPSB7XG4gICAgaW5zdGFuY2U6IHRoaXMsXG4gICAgc3R5bGVzOiB7fSxcbiAgICBhcnJvd1N0eWxlczoge30sXG4gICAgYXR0cmlidXRlczoge30sXG4gICAgZmxpcHBlZDogZmFsc2UsXG4gICAgb2Zmc2V0czoge31cbiAgfTtcblxuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZU9mZnNldHModGhpcy5zdGF0ZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIGRhdGEucGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQodGhpcy5vcHRpb25zLnBsYWNlbWVudCwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgdGhpcy5wb3BwZXIsIHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICAvLyBzdG9yZSB0aGUgY29tcHV0ZWQgcGxhY2VtZW50IGluc2lkZSBgb3JpZ2luYWxQbGFjZW1lbnRgXG4gIGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcblxuICBkYXRhLnBvc2l0aW9uRml4ZWQgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZDtcblxuICAvLyBjb21wdXRlIHRoZSBwb3BwZXIgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0UG9wcGVyT2Zmc2V0cyh0aGlzLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPSB0aGlzLm9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnO1xuXG4gIC8vIHJ1biB0aGUgbW9kaWZpZXJzXG4gIGRhdGEgPSBydW5Nb2RpZmllcnModGhpcy5tb2RpZmllcnMsIGRhdGEpO1xuXG4gIC8vIHRoZSBmaXJzdCBgdXBkYXRlYCB3aWxsIGNhbGwgYG9uQ3JlYXRlYCBjYWxsYmFja1xuICAvLyB0aGUgb3RoZXIgb25lcyB3aWxsIGNhbGwgYG9uVXBkYXRlYCBjYWxsYmFja1xuICBpZiAoIXRoaXMuc3RhdGUuaXNDcmVhdGVkKSB7XG4gICAgdGhpcy5zdGF0ZS5pc0NyZWF0ZWQgPSB0cnVlO1xuICAgIHRoaXMub3B0aW9ucy5vbkNyZWF0ZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm9wdGlvbnMub25VcGRhdGUoZGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBpcyBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJFbmFibGVkKG1vZGlmaWVycywgbW9kaWZpZXJOYW1lKSB7XG4gIHJldHVybiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICBlbmFibGVkID0gX3JlZi5lbmFibGVkO1xuICAgIHJldHVybiBlbmFibGVkICYmIG5hbWUgPT09IG1vZGlmaWVyTmFtZTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmaXhlZCBzdXBwb3J0ZWQgcHJvcGVydHkgbmFtZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBwcmVmaXhlZCBwcm9wZXJ0eSAoY2FtZWxDYXNlIG9yIFBhc2NhbENhc2UsIGRlcGVuZGluZyBvbiB0aGUgdmVuZG9yIHByZWZpeClcbiAqL1xuZnVuY3Rpb24gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ21zJywgJ1dlYmtpdCcsICdNb3onLCAnTyddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveXMgdGhlIHBvcHBlci5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgdGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCA9IHRydWU7XG5cbiAgLy8gdG91Y2ggRE9NIG9ubHkgaWYgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGlzIGVuYWJsZWRcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKHRoaXMubW9kaWZpZXJzLCAnYXBwbHlTdHlsZScpKSB7XG4gICAgdGhpcy5wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnBvc2l0aW9uID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUudG9wID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnJpZ2h0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUuYm90dG9tID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUud2lsbENoYW5nZSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlW2dldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyldID0gJyc7XG4gIH1cblxuICB0aGlzLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuXG4gIC8vIHJlbW92ZSB0aGUgcG9wcGVyIGlmIHVzZXIgZXhwbGljaXRseSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aW5kb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtZW50KSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWSc7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBzY3JvbGxQYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHNjcm9sbFBhcmVudDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgaWYgKCFpc0JvZHkpIHtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldC5wYXJlbnROb2RlKSwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKTtcbiAgfVxuICBzY3JvbGxQYXJlbnRzLnB1c2godGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBvcHRpb25zLCBzdGF0ZSwgdXBkYXRlQm91bmQpIHtcbiAgLy8gUmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBzdGF0ZS51cGRhdGVCb3VuZCA9IHVwZGF0ZUJvdW5kO1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIC8vIFNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICB2YXIgc2Nyb2xsRWxlbWVudCA9IGdldFNjcm9sbFBhcmVudChyZWZlcmVuY2UpO1xuICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsRWxlbWVudCwgJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kLCBzdGF0ZS5zY3JvbGxQYXJlbnRzKTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIGFkZCByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgc3RhcnQgcmVjYWxjdWxhdGluZ1xuICogcG9zaXRpb24gb2YgdGhlIHBvcHBlciBlbGVtZW50IHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc2V0dXBFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLCB0aGlzLnN0YXRlLCB0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBzdGF0ZSkge1xuICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgLy8gUmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IHN0YXRlXG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IFtdO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCByZW1vdmUgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHdvbid0IHJlY2FsY3VsYXRlIHBvcHBlciBwb3NpdGlvblxuICogd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuIEl0IGFsc28gd29uJ3QgdHJpZ2dlciBgb25VcGRhdGVgIGNhbGxiYWNrIGFueW1vcmUsXG4gKiB1bmxlc3MgeW91IGNhbGwgYHVwZGF0ZWAgbWV0aG9kIG1hbnVhbGx5LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICh0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgICB0aGlzLnN0YXRlID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMuc3RhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGVsbHMgaWYgYSBnaXZlbiBpbnB1dCBpcyBhIG51bWJlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHsqfSBpbnB1dCB0byBjaGVja1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNOdW1lcmljKG4pIHtcbiAgcmV0dXJuIG4gIT09ICcnICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHN0eWxlIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRTdHlsZXMoZWxlbWVudCwgc3R5bGVzKSB7XG4gIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB1bml0ID0gJyc7XG4gICAgLy8gYWRkIHVuaXQgaWYgdGhlIHZhbHVlIGlzIG51bWVyaWMgYW5kIGlzIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzTnVtZXJpYyhzdHlsZXNbcHJvcF0pKSB7XG4gICAgICB1bml0ID0gJ3B4JztcbiAgICB9XG4gICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBhdHRyaWJ1dGVzIHRvXG4gKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzXG4gKiBPYmplY3Qgd2l0aCBhIGxpc3Qgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbcHJvcF07XG4gICAgaWYgKHZhbHVlICE9PSBmYWxzZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUocHJvcCwgYXR0cmlidXRlc1twcm9wXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5zdHlsZXMgLSBMaXN0IG9mIHN0eWxlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLmF0dHJpYnV0ZXMgLSBMaXN0IG9mIGF0dHJpYnV0ZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc2FtZSBkYXRhIG9iamVjdFxuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlKGRhdGEpIHtcbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuc3R5bGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gaW4gdGhpcyB3YXkgd2UgY2FuIG1ha2UgdGhlIDNyZCBwYXJ0eSBtb2RpZmllcnMgYWRkIGN1c3RvbSBzdHlsZXMgdG8gaXRcbiAgLy8gQmUgYXdhcmUsIG1vZGlmaWVycyBjb3VsZCBvdmVycmlkZSB0aGUgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoZSBwcmV2aW91c1xuICAvLyBsaW5lcyBvZiB0aGlzIG1vZGlmaWVyIVxuICBzZXRTdHlsZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuc3R5bGVzKTtcblxuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5hdHRyaWJ1dGVzYCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlcixcbiAgLy8gdGhleSB3aWxsIGJlIHNldCBhcyBIVE1MIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnRcbiAgc2V0QXR0cmlidXRlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgZGVmaW5lZCBhbmQgYXJyb3dTdHlsZXMgaGFzIHNvbWUgcHJvcGVydGllc1xuICBpZiAoZGF0YS5hcnJvd0VsZW1lbnQgJiYgT2JqZWN0LmtleXMoZGF0YS5hcnJvd1N0eWxlcykubGVuZ3RoKSB7XG4gICAgc2V0U3R5bGVzKGRhdGEuYXJyb3dFbGVtZW50LCBkYXRhLmFycm93U3R5bGVzKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNldCB0aGUgeC1wbGFjZW1lbnQgYXR0cmlidXRlIGJlZm9yZSBldmVyeXRoaW5nIGVsc2UgYmVjYXVzZSBpdCBjb3VsZCBiZSB1c2VkXG4gKiB0byBhZGQgbWFyZ2lucyB0byB0aGUgcG9wcGVyIG1hcmdpbnMgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBnZXQgdGhlXG4gKiBjb3JyZWN0IHBvcHBlciBvZmZzZXRzLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUG9wcGVyLmpzIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZU9uTG9hZChyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBzdGF0ZSkge1xuICAvLyBjb21wdXRlIHJlZmVyZW5jZSBlbGVtZW50IG9mZnNldHNcbiAgdmFyIHJlZmVyZW5jZU9mZnNldHMgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJyB9KTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gc2hvdWxkUm91bmQgLSBJZiB0aGUgb2Zmc2V0cyBzaG91bGQgYmUgcm91bmRlZCBhdCBhbGxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBwb3BwZXIncyBwb3NpdGlvbiBvZmZzZXRzIHJvdW5kZWRcbiAqXG4gKiBUaGUgdGFsZSBvZiBwaXhlbC1wZXJmZWN0IHBvc2l0aW9uaW5nLiBJdCdzIHN0aWxsIG5vdCAxMDAlIHBlcmZlY3QsIGJ1dCBhc1xuICogZ29vZCBhcyBpdCBjYW4gYmUgd2l0aGluIHJlYXNvbi5cbiAqIERpc2N1c3Npb24gaGVyZTogaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvcHVsbC83MTVcbiAqXG4gKiBMb3cgRFBJIHNjcmVlbnMgY2F1c2UgYSBwb3BwZXIgdG8gYmUgYmx1cnJ5IGlmIG5vdCB1c2luZyBmdWxsIHBpeGVscyAoU2FmYXJpXG4gKiBhcyB3ZWxsIG9uIEhpZ2ggRFBJIHNjcmVlbnMpLlxuICpcbiAqIEZpcmVmb3ggcHJlZmVycyBubyByb3VuZGluZyBmb3IgcG9zaXRpb25pbmcgYW5kIGRvZXMgbm90IGhhdmUgYmx1cnJpbmVzcyBvblxuICogaGlnaCBEUEkgc2NyZWVucy5cbiAqXG4gKiBPbmx5IGhvcml6b250YWwgcGxhY2VtZW50IGFuZCBsZWZ0L3JpZ2h0IHZhbHVlcyBuZWVkIHRvIGJlIGNvbnNpZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHNob3VsZFJvdW5kKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIHJvdW5kID0gTWF0aC5yb3VuZCxcbiAgICAgIGZsb29yID0gTWF0aC5mbG9vcjtcblxuICB2YXIgbm9Sb3VuZCA9IGZ1bmN0aW9uIG5vUm91bmQodikge1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIHZhciByZWZlcmVuY2VXaWR0aCA9IHJvdW5kKHJlZmVyZW5jZS53aWR0aCk7XG4gIHZhciBwb3BwZXJXaWR0aCA9IHJvdW5kKHBvcHBlci53aWR0aCk7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGRhdGEucGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBpc1ZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LmluZGV4T2YoJy0nKSAhPT0gLTE7XG4gIHZhciBzYW1lV2lkdGhQYXJpdHkgPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IHBvcHBlcldpZHRoICUgMjtcbiAgdmFyIGJvdGhPZGRXaWR0aCA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gMSAmJiBwb3BwZXJXaWR0aCAlIDIgPT09IDE7XG5cbiAgdmFyIGhvcml6b250YWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogaXNWZXJ0aWNhbCB8fCBpc1ZhcmlhdGlvbiB8fCBzYW1lV2lkdGhQYXJpdHkgPyByb3VuZCA6IGZsb29yO1xuICB2YXIgdmVydGljYWxUb0ludGVnZXIgPSAhc2hvdWxkUm91bmQgPyBub1JvdW5kIDogcm91bmQ7XG5cbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiBob3Jpem9udGFsVG9JbnRlZ2VyKGJvdGhPZGRXaWR0aCAmJiAhaXNWYXJpYXRpb24gJiYgc2hvdWxkUm91bmQgPyBwb3BwZXIubGVmdCAtIDEgOiBwb3BwZXIubGVmdCksXG4gICAgdG9wOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIudG9wKSxcbiAgICBib3R0b206IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBob3Jpem9udGFsVG9JbnRlZ2VyKHBvcHBlci5yaWdodClcbiAgfTtcbn1cblxudmFyIGlzRmlyZWZveCA9IGlzQnJvd3NlciAmJiAvRmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZShkYXRhLCBvcHRpb25zKSB7XG4gIHZhciB4ID0gb3B0aW9ucy54LFxuICAgICAgeSA9IG9wdGlvbnMueTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgLy8gUmVtb3ZlIHRoaXMgbGVnYWN5IHN1cHBvcnQgaW4gUG9wcGVyLmpzIHYyXG5cbiAgdmFyIGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICB2YXIgb2Zmc2V0cyA9IGdldFJvdW5kZWRPZmZzZXRzKGRhdGEsIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDwgMiB8fCAhaXNGaXJlZm94KTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICAvLyB3aGVuIG9mZnNldFBhcmVudCBpcyA8aHRtbD4gdGhlIHBvc2l0aW9uaW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBib3R0b20gb2YgdGhlIHNjcmVlbiAoZXhjbHVkaW5nIHRoZSBzY3JvbGxiYXIpXG4gICAgLy8gYW5kIG5vdCB0aGUgYm90dG9tIG9mIHRoZSBodG1sIGVsZW1lbnRcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvcCA9IC1vZmZzZXRQYXJlbnRSZWN0LmhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnRSZWN0LndpZHRoICsgb2Zmc2V0cy5yaWdodDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGVmdCA9IG9mZnNldHMubGVmdDtcbiAgfVxuICBpZiAoZ3B1QWNjZWxlcmF0aW9uICYmIHByZWZpeGVkUHJvcGVydHkpIHtcbiAgICBzdHlsZXNbcHJlZml4ZWRQcm9wZXJ0eV0gPSAndHJhbnNsYXRlM2QoJyArIGxlZnQgKyAncHgsICcgKyB0b3AgKyAncHgsIDApJztcbiAgICBzdHlsZXNbc2lkZUFdID0gMDtcbiAgICBzdHlsZXNbc2lkZUJdID0gMDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9ICd0cmFuc2Zvcm0nO1xuICB9IGVsc2Uge1xuICAgIC8vIG90aHdlcmlzZSwgd2UgdXNlIHRoZSBzdGFuZGFyZCBgdG9wYCwgYGxlZnRgLCBgYm90dG9tYCBhbmQgYHJpZ2h0YCBwcm9wZXJ0aWVzXG4gICAgdmFyIGludmVydFRvcCA9IHNpZGVBID09PSAnYm90dG9tJyA/IC0xIDogMTtcbiAgICB2YXIgaW52ZXJ0TGVmdCA9IHNpZGVCID09PSAncmlnaHQnID8gLTEgOiAxO1xuICAgIHN0eWxlc1tzaWRlQV0gPSB0b3AgKiBpbnZlcnRUb3A7XG4gICAgc3R5bGVzW3NpZGVCXSA9IGxlZnQgKiBpbnZlcnRMZWZ0O1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gc2lkZUEgKyAnLCAnICsgc2lkZUI7XG4gIH1cblxuICAvLyBBdHRyaWJ1dGVzXG4gIHZhciBhdHRyaWJ1dGVzID0ge1xuICAgICd4LXBsYWNlbWVudCc6IGRhdGEucGxhY2VtZW50XG4gIH07XG5cbiAgLy8gVXBkYXRlIGBkYXRhYCBhdHRyaWJ1dGVzLCBzdHlsZXMgYW5kIGFycm93U3R5bGVzXG4gIGRhdGEuYXR0cmlidXRlcyA9IF9leHRlbmRzKHt9LCBhdHRyaWJ1dGVzLCBkYXRhLmF0dHJpYnV0ZXMpO1xuICBkYXRhLnN0eWxlcyA9IF9leHRlbmRzKHt9LCBzdHlsZXMsIGRhdGEuc3R5bGVzKTtcbiAgZGF0YS5hcnJvd1N0eWxlcyA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMuYXJyb3csIGRhdGEuYXJyb3dTdHlsZXMpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGRlcGVuZHMgZnJvbSBhbm90aGVyIG9uZS48YnIgLz5cbiAqIEl0IGNoZWNrcyBpZiB0aGUgbmVlZGVkIG1vZGlmaWVyIGlzIGxpc3RlZCBhbmQgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVycyAtIGxpc3Qgb2YgbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZ05hbWUgLSBuYW1lIG9mIHJlcXVlc3RpbmcgbW9kaWZpZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWROYW1lIC0gbmFtZSBvZiByZXF1ZXN0ZWQgbW9kaWZpZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyUmVxdWlyZWQobW9kaWZpZXJzLCByZXF1ZXN0aW5nTmFtZSwgcmVxdWVzdGVkTmFtZSkge1xuICB2YXIgcmVxdWVzdGluZyA9IGZpbmQobW9kaWZpZXJzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHJldHVybiBuYW1lID09PSByZXF1ZXN0aW5nTmFtZTtcbiAgfSk7XG5cbiAgdmFyIGlzUmVxdWlyZWQgPSAhIXJlcXVlc3RpbmcgJiYgbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09IHJlcXVlc3RlZE5hbWUgJiYgbW9kaWZpZXIuZW5hYmxlZCAmJiBtb2RpZmllci5vcmRlciA8IHJlcXVlc3Rpbmcub3JkZXI7XG4gIH0pO1xuXG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIHZhciBfcmVxdWVzdGluZyA9ICdgJyArIHJlcXVlc3RpbmdOYW1lICsgJ2AnO1xuICAgIHZhciByZXF1ZXN0ZWQgPSAnYCcgKyByZXF1ZXN0ZWROYW1lICsgJ2AnO1xuICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBhcnJvd0VsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpc24ndCBhIHF1ZXJ5IHNlbGVjdG9yIHdlIG11c3QgY2hlY2sgdGhhdCB0aGVcbiAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICBpZiAoIWRhdGEuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIHZhciBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdW5jdGlvblxuICAvL1xuXG4gIC8vIHRvcC9sZWZ0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLT0gcG9wcGVyW3NpZGVdIC0gKHJlZmVyZW5jZVtvcFNpZGVdIC0gYXJyb3dFbGVtZW50U2l6ZSk7XG4gIH1cbiAgLy8gYm90dG9tL3JpZ2h0IHNpZGVcbiAgaWYgKHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gKz0gcmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSAtIHBvcHBlcltvcFNpZGVdO1xuICB9XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVtsZW5dIC8gMiAtIGFycm93RWxlbWVudFNpemUgLyAyO1xuXG4gIC8vIENvbXB1dGUgdGhlIHNpZGVWYWx1ZSB1c2luZyB0aGUgdXBkYXRlZCBwb3BwZXIgb2Zmc2V0c1xuICAvLyB0YWtlIHBvcHBlciBtYXJnaW4gaW4gYWNjb3VudCBiZWNhdXNlIHdlIGRvbid0IGhhdmUgdGhpcyBpbmZvIGF2YWlsYWJsZVxuICB2YXIgY3NzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIHBvcHBlck1hcmdpblNpZGUgPSBwYXJzZUZsb2F0KGNzc1snbWFyZ2luJyArIHNpZGVDYXBpdGFsaXplZF0pO1xuICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10pO1xuICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtIHBvcHBlck1hcmdpblNpZGUgLSBwb3BwZXJCb3JkZXJTaWRlO1xuXG4gIC8vIHByZXZlbnQgYXJyb3dFbGVtZW50IGZyb20gYmVpbmcgcGxhY2VkIG5vdCBjb250aWd1b3VzbHkgdG8gaXRzIHBvcHBlclxuICBzaWRlVmFsdWUgPSBNYXRoLm1heChNYXRoLm1pbihwb3BwZXJbbGVuXSAtIGFycm93RWxlbWVudFNpemUsIHNpZGVWYWx1ZSksIDApO1xuXG4gIGRhdGEuYXJyb3dFbGVtZW50ID0gYXJyb3dFbGVtZW50O1xuICBkYXRhLm9mZnNldHMuYXJyb3cgPSAoX2RhdGEkb2Zmc2V0cyRhcnJvdyA9IHt9LCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBzaWRlLCBNYXRoLnJvdW5kKHNpZGVWYWx1ZSkpLCBkZWZpbmVQcm9wZXJ0eShfZGF0YSRvZmZzZXRzJGFycm93LCBhbHRTaWRlLCAnJyksIF9kYXRhJG9mZnNldHMkYXJyb3cpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IHZhcmlhdGlvbiBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IHZhcmlhdGlvblxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbikge1xuICBpZiAodmFyaWF0aW9uID09PSAnZW5kJykge1xuICAgIHJldHVybiAnc3RhcnQnO1xuICB9IGVsc2UgaWYgKHZhcmlhdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgIHJldHVybiAnZW5kJztcbiAgfVxuICByZXR1cm4gdmFyaWF0aW9uO1xufVxuXG4vKipcbiAqIExpc3Qgb2YgYWNjZXB0ZWQgcGxhY2VtZW50cyB0byB1c2UgYXMgdmFsdWVzIG9mIHRoZSBgcGxhY2VtZW50YCBvcHRpb24uPGJyIC8+XG4gKiBWYWxpZCBwbGFjZW1lbnRzIGFyZTpcbiAqIC0gYGF1dG9gXG4gKiAtIGB0b3BgXG4gKiAtIGByaWdodGBcbiAqIC0gYGJvdHRvbWBcbiAqIC0gYGxlZnRgXG4gKlxuICogRWFjaCBwbGFjZW1lbnQgY2FuIGhhdmUgYSB2YXJpYXRpb24gZnJvbSB0aGlzIGxpc3Q6XG4gKiAtIGAtc3RhcnRgXG4gKiAtIGAtZW5kYFxuICpcbiAqIFZhcmlhdGlvbnMgYXJlIGludGVycHJldGVkIGVhc2lseSBpZiB5b3UgdGhpbmsgb2YgdGhlbSBhcyB0aGUgbGVmdCB0byByaWdodFxuICogd3JpdHRlbiBsYW5ndWFnZXMuIEhvcml6b250YWxseSAoYHRvcGAgYW5kIGBib3R0b21gKSwgYHN0YXJ0YCBpcyBsZWZ0IGFuZCBgZW5kYFxuICogaXMgcmlnaHQuPGJyIC8+XG4gKiBWZXJ0aWNhbGx5IChgbGVmdGAgYW5kIGByaWdodGApLCBgc3RhcnRgIGlzIHRvcCBhbmQgYGVuZGAgaXMgYm90dG9tLlxuICpcbiAqIFNvbWUgdmFsaWQgZXhhbXBsZXMgYXJlOlxuICogLSBgdG9wLWVuZGAgKG9uIHRvcCBvZiByZWZlcmVuY2UsIHJpZ2h0IGFsaWduZWQpXG4gKiAtIGByaWdodC1zdGFydGAgKG9uIHJpZ2h0IG9mIHJlZmVyZW5jZSwgdG9wIGFsaWduZWQpXG4gKiAtIGBib3R0b21gIChvbiBib3R0b20sIGNlbnRlcmVkKVxuICogLSBgYXV0by1lbmRgIChvbiB0aGUgc2lkZSB3aXRoIG1vcmUgc3BhY2UgYXZhaWxhYmxlLCBhbGlnbm1lbnQgZGVwZW5kcyBieSBwbGFjZW1lbnQpXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge0FycmF5fVxuICogQGVudW0ge1N0cmluZ31cbiAqIEByZWFkb25seVxuICogQG1ldGhvZCBwbGFjZW1lbnRzXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBwbGFjZW1lbnRzID0gWydhdXRvLXN0YXJ0JywgJ2F1dG8nLCAnYXV0by1lbmQnLCAndG9wLXN0YXJ0JywgJ3RvcCcsICd0b3AtZW5kJywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20tZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnbGVmdC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0J107XG5cbi8vIEdldCByaWQgb2YgYGF1dG9gIGBhdXRvLXN0YXJ0YCBhbmQgYGF1dG8tZW5kYFxudmFyIHZhbGlkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuc2xpY2UoMyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5pdGlhbCBwbGFjZW1lbnQsIHJldHVybnMgYWxsIHRoZSBzdWJzZXF1ZW50IHBsYWNlbWVudHNcbiAqIGNsb2Nrd2lzZSAob3IgY291bnRlci1jbG9ja3dpc2UpLlxuICpcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgLSBBIHZhbGlkIHBsYWNlbWVudCAoaXQgYWNjZXB0cyB2YXJpYXRpb25zKVxuICogQGFyZ3VtZW50IHtCb29sZWFufSBjb3VudGVyIC0gU2V0IHRvIHRydWUgdG8gd2FsayB0aGUgcGxhY2VtZW50cyBjb3VudGVyY2xvY2t3aXNlXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBsYWNlbWVudHMgaW5jbHVkaW5nIHRoZWlyIHZhcmlhdGlvbnNcbiAqL1xuZnVuY3Rpb24gY2xvY2t3aXNlKHBsYWNlbWVudCkge1xuICB2YXIgY291bnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGluZGV4ID0gdmFsaWRQbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KTtcbiAgdmFyIGFyciA9IHZhbGlkUGxhY2VtZW50cy5zbGljZShpbmRleCArIDEpLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxuXG52YXIgQkVIQVZJT1JTID0ge1xuICBGTElQOiAnZmxpcCcsXG4gIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXG4gIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJ1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGZsaXAoZGF0YSwgb3B0aW9ucykge1xuICAvLyBpZiBgaW5uZXJgIG1vZGlmaWVyIGlzIGVuYWJsZWQsIHdlIGNhbid0IHVzZSB0aGUgYGZsaXBgIG1vZGlmaWVyXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2lubmVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmIChkYXRhLmZsaXBwZWQgJiYgZGF0YS5wbGFjZW1lbnQgPT09IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQpIHtcbiAgICAvLyBzZWVtcyBsaWtlIGZsaXAgaXMgdHJ5aW5nIHRvIGxvb3AsIHByb2JhYmx5IHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBvbiBhbnkgb2YgdGhlIGZsaXBwYWJsZSBzaWRlc1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVsxXSB8fCAnJztcblxuICB2YXIgZmxpcE9yZGVyID0gW107XG5cbiAgc3dpdGNoIChvcHRpb25zLmJlaGF2aW9yKSB7XG4gICAgY2FzZSBCRUhBVklPUlMuRkxJUDpcbiAgICAgIGZsaXBPcmRlciA9IFtwbGFjZW1lbnQsIHBsYWNlbWVudE9wcG9zaXRlXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ09VTlRFUkNMT0NLV0lTRTpcbiAgICAgIGZsaXBPcmRlciA9IGNsb2Nrd2lzZShwbGFjZW1lbnQsIHRydWUpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGZsaXBPcmRlciA9IG9wdGlvbnMuYmVoYXZpb3I7XG4gIH1cblxuICBmbGlwT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICBpZiAocGxhY2VtZW50ICE9PSBzdGVwIHx8IGZsaXBPcmRlci5sZW5ndGggPT09IGluZGV4ICsgMSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG4gICAgdmFyIHJlZk9mZnNldHMgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuXG4gICAgLy8gdXNpbmcgZmxvb3IgYmVjYXVzZSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgbWF5IGNvbnRhaW4gZGVjaW1hbHMgd2UgYXJlIG5vdCBnb2luZyB0byBjb25zaWRlciBoZXJlXG4gICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICB2YXIgb3ZlcmxhcHNSZWYgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKHJlZk9mZnNldHMubGVmdCkgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihyZWZPZmZzZXRzLnJpZ2h0KSB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKHJlZk9mZnNldHMudG9wKSB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKHJlZk9mZnNldHMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NMZWZ0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKGJvdW5kYXJpZXMubGVmdCk7XG4gICAgdmFyIG92ZXJmbG93c1JpZ2h0ID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihib3VuZGFyaWVzLnJpZ2h0KTtcbiAgICB2YXIgb3ZlcmZsb3dzVG9wID0gZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IoYm91bmRhcmllcy50b3ApO1xuICAgIHZhciBvdmVyZmxvd3NCb3R0b20gPSBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihib3VuZGFyaWVzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzQm91bmRhcmllcyA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIG92ZXJmbG93c0xlZnQgfHwgcGxhY2VtZW50ID09PSAncmlnaHQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgb3ZlcmZsb3dzVG9wIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgb3ZlcmZsb3dzQm90dG9tO1xuXG4gICAgLy8gZmxpcCB0aGUgdmFyaWF0aW9uIGlmIHJlcXVpcmVkXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb25CeVJlZiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcG9wcGVyIGNvbnRlbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudCA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9uc0J5Q29udGVudCAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0xlZnQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0JvdHRvbSB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1RvcCk7XG5cbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9IGZsaXBwZWRWYXJpYXRpb25CeVJlZiB8fCBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50O1xuXG4gICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMgfHwgZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgLy8gdGhpcyBib29sZWFuIHRvIGRldGVjdCBhbnkgZmxpcCBsb29wXG4gICAgICBkYXRhLmZsaXBwZWQgPSB0cnVlO1xuXG4gICAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcykge1xuICAgICAgICBwbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgICAgdmFyaWF0aW9uID0gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgZGF0YS5wbGFjZW1lbnQgPSBwbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xuXG4gICAgICAvLyB0aGlzIG9iamVjdCBjb250YWlucyBgcG9zaXRpb25gLCB3ZSB3YW50IHRvIHByZXNlcnZlIGl0IGFsb25nIHdpdGhcbiAgICAgIC8vIGFueSBhZGRpdGlvbmFsIHByb3BlcnR5IHdlIG1heSBhZGQgaW4gdGhlIGZ1dHVyZVxuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBkYXRhLm9mZnNldHMucG9wcGVyLCBnZXRQb3BwZXJPZmZzZXRzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCkpO1xuXG4gICAgICBkYXRhID0gcnVuTW9kaWZpZXJzKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBkYXRhLCAnZmxpcCcpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24ga2VlcFRvZ2V0aGVyKGRhdGEpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdyaWdodCcgOiAnYm90dG9tJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICBpZiAocG9wcGVyW3NpZGVdIDwgZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW29wU2lkZV0pIC0gcG9wcGVyW21lYXN1cmVtZW50XTtcbiAgfVxuICBpZiAocG9wcGVyW29wU2lkZV0gPiBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltvcFNpZGVdID0gZmxvb3IocmVmZXJlbmNlW3NpZGVdKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIGNvbnRhaW5pbmcgdmFsdWUgKyB1bml0IGludG8gYSBweCB2YWx1ZSBudW1iZXJcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzdHIgLSBWYWx1ZSArIHVuaXQgc3RyaW5nXG4gKiBAYXJndW1lbnQge1N0cmluZ30gbWVhc3VyZW1lbnQgLSBgaGVpZ2h0YCBvciBgd2lkdGhgXG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEByZXR1cm5zIHtOdW1iZXJ8U3RyaW5nfVxuICogVmFsdWUgaW4gcGl4ZWxzLCBvciBvcmlnaW5hbCBzdHJpbmcgaWYgbm8gdmFsdWVzIHdlcmUgZXh0cmFjdGVkXG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cykge1xuICAvLyBzZXBhcmF0ZSB2YWx1ZSBmcm9tIHVuaXRcbiAgdmFyIHNwbGl0ID0gc3RyLm1hdGNoKC8oKD86XFwtfFxcKyk/XFxkKlxcLj9cXGQqKSguKikvKTtcbiAgdmFyIHZhbHVlID0gK3NwbGl0WzFdO1xuICB2YXIgdW5pdCA9IHNwbGl0WzJdO1xuXG4gIC8vIElmIGl0J3Mgbm90IGEgbnVtYmVyIGl0J3MgYW4gb3BlcmF0b3IsIEkgZ3Vlc3NcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBpZiAodW5pdC5pbmRleE9mKCclJykgPT09IDApIHtcbiAgICB2YXIgZWxlbWVudCA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHVuaXQpIHtcbiAgICAgIGNhc2UgJyVwJzpcbiAgICAgICAgZWxlbWVudCA9IHBvcHBlck9mZnNldHM7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnJSc6XG4gICAgICBjYXNlICclcic6XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBlbGVtZW50ID0gcmVmZXJlbmNlT2Zmc2V0cztcbiAgICB9XG5cbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3QoZWxlbWVudCk7XG4gICAgcmV0dXJuIHJlY3RbbWVhc3VyZW1lbnRdIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3ZoJyB8fCB1bml0ID09PSAndncnKSB7XG4gICAgLy8gaWYgaXMgYSB2aCBvciB2dywgd2UgY2FsY3VsYXRlIHRoZSBzaXplIGJhc2VkIG9uIHRoZSB2aWV3cG9ydFxuICAgIHZhciBzaXplID0gdm9pZCAwO1xuICAgIGlmICh1bml0ID09PSAndmgnKSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLCB3aW5kb3cuaW5uZXJXaWR0aCB8fCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemUgLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpZiBpcyBhbiBleHBsaWNpdCBwaXhlbCB1bml0LCB3ZSBnZXQgcmlkIG9mIHRoZSB1bml0IGFuZCBrZWVwIHRoZSB2YWx1ZVxuICAgIC8vIGlmIGlzIGFuIGltcGxpY2l0IHVuaXQsIGl0J3MgcHgsIGFuZCB3ZSByZXR1cm4ganVzdCB0aGUgdmFsdWVcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBgb2Zmc2V0YCBzdHJpbmcgdG8gZXh0cmFwb2xhdGUgYHhgIGFuZCBgeWAgbnVtZXJpYyBvZmZzZXRzLlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IG9mZnNldFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gYmFzZVBsYWNlbWVudFxuICogQHJldHVybnMge0FycmF5fSBhIHR3byBjZWxscyBhcnJheSB3aXRoIHggYW5kIHkgb2Zmc2V0cyBpbiBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cywgYmFzZVBsYWNlbWVudCkge1xuICB2YXIgb2Zmc2V0cyA9IFswLCAwXTtcblxuICAvLyBVc2UgaGVpZ2h0IGlmIHBsYWNlbWVudCBpcyBsZWZ0IG9yIHJpZ2h0IGFuZCBpbmRleCBpcyAwIG90aGVyd2lzZSB1c2Ugd2lkdGhcbiAgLy8gaW4gdGhpcyB3YXkgdGhlIGZpcnN0IG9mZnNldCB3aWxsIHVzZSBhbiBheGlzIGFuZCB0aGUgc2Vjb25kIG9uZVxuICAvLyB3aWxsIHVzZSB0aGUgb3RoZXIgb25lXG4gIHZhciB1c2VIZWlnaHQgPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAvLyBTcGxpdCB0aGUgb2Zmc2V0IHN0cmluZyB0byBvYnRhaW4gYSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHNcbiAgLy8gVGhlIHJlZ2V4IGFkZHJlc3NlcyB2YWx1ZXMgd2l0aCB0aGUgcGx1cyBvciBtaW51cyBzaWduIGluIGZyb250ICgrMTAsIC0yMCwgZXRjKVxuICB2YXIgZnJhZ21lbnRzID0gb2Zmc2V0LnNwbGl0KC8oXFwrfFxcLSkvKS5tYXAoZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy50cmltKCk7XG4gIH0pO1xuXG4gIC8vIERldGVjdCBpZiB0aGUgb2Zmc2V0IHN0cmluZyBjb250YWlucyBhIHBhaXIgb2YgdmFsdWVzIG9yIGEgc2luZ2xlIG9uZVxuICAvLyB0aGV5IGNvdWxkIGJlIHNlcGFyYXRlZCBieSBjb21tYSBvciBzcGFjZVxuICB2YXIgZGl2aWRlciA9IGZyYWdtZW50cy5pbmRleE9mKGZpbmQoZnJhZ21lbnRzLCBmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnNlYXJjaCgvLHxcXHMvKSAhPT0gLTE7XG4gIH0pKTtcblxuICBpZiAoZnJhZ21lbnRzW2RpdmlkZXJdICYmIGZyYWdtZW50c1tkaXZpZGVyXS5pbmRleE9mKCcsJykgPT09IC0xKSB7XG4gICAgY29uc29sZS53YXJuKCdPZmZzZXRzIHNlcGFyYXRlZCBieSB3aGl0ZSBzcGFjZShzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIGEgY29tbWEgKCwpIGluc3RlYWQuJyk7XG4gIH1cblxuICAvLyBJZiBkaXZpZGVyIGlzIGZvdW5kLCB3ZSBkaXZpZGUgdGhlIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kcyB0byBkaXZpZGVcbiAgLy8gdGhlbSBieSBvZnNldCBYIGFuZCBZLlxuICB2YXIgc3BsaXRSZWdleCA9IC9cXHMqLFxccyp8XFxzKy87XG4gIHZhciBvcHMgPSBkaXZpZGVyICE9PSAtMSA/IFtmcmFnbWVudHMuc2xpY2UoMCwgZGl2aWRlcikuY29uY2F0KFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMF1dKSwgW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVsxXV0uY29uY2F0KGZyYWdtZW50cy5zbGljZShkaXZpZGVyICsgMSkpXSA6IFtmcmFnbWVudHNdO1xuXG4gIC8vIENvbnZlcnQgdGhlIHZhbHVlcyB3aXRoIHVuaXRzIHRvIGFic29sdXRlIHBpeGVscyB0byBhbGxvdyBvdXIgY29tcHV0YXRpb25zXG4gIG9wcyA9IG9wcy5tYXAoZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIC8vIE1vc3Qgb2YgdGhlIHVuaXRzIHJlbHkgb24gdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBwb3BwZXJcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSAoaW5kZXggPT09IDEgPyAhdXNlSGVpZ2h0IDogdXNlSGVpZ2h0KSA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICByZXR1cm4gb3BcbiAgICAvLyBUaGlzIGFnZ3JlZ2F0ZXMgYW55IGArYCBvciBgLWAgc2lnbiB0aGF0IGFyZW4ndCBjb25zaWRlcmVkIG9wZXJhdG9yc1xuICAgIC8vIGUuZy46IDEwICsgKzUgPT4gWzEwLCArLCArNV1cbiAgICAucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICBpZiAoYVthLmxlbmd0aCAtIDFdID09PSAnJyAmJiBbJysnLCAnLSddLmluZGV4T2YoYikgIT09IC0xKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSA9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2UgaWYgKG1lcmdlV2l0aFByZXZpb3VzKSB7XG4gICAgICAgIGFbYS5sZW5ndGggLSAxXSArPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH1cbiAgICB9LCBbXSlcbiAgICAvLyBIZXJlIHdlIGNvbnZlcnQgdGhlIHN0cmluZyB2YWx1ZXMgaW50byBudW1iZXIgdmFsdWVzIChpbiBweClcbiAgICAubWFwKGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBMb29wIHRyb3VnaCB0aGUgb2Zmc2V0cyBhcnJheXMgYW5kIGV4ZWN1dGUgdGhlIG9wZXJhdGlvbnNcbiAgb3BzLmZvckVhY2goZnVuY3Rpb24gKG9wLCBpbmRleCkge1xuICAgIG9wLmZvckVhY2goZnVuY3Rpb24gKGZyYWcsIGluZGV4Mikge1xuICAgICAgaWYgKGlzTnVtZXJpYyhmcmFnKSkge1xuICAgICAgICBvZmZzZXRzW2luZGV4XSArPSBmcmFnICogKG9wW2luZGV4MiAtIDFdID09PSAnLScgPyAtMSA6IDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQGFyZ3VtZW50IHtOdW1iZXJ8U3RyaW5nfSBvcHRpb25zLm9mZnNldD0wXG4gKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gb2Zmc2V0KGRhdGEsIF9yZWYpIHtcbiAgdmFyIG9mZnNldCA9IF9yZWYub2Zmc2V0O1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQsXG4gICAgICBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIHZhciBvZmZzZXRzID0gdm9pZCAwO1xuICBpZiAoaXNOdW1lcmljKCtvZmZzZXQpKSB7XG4gICAgb2Zmc2V0cyA9IFsrb2Zmc2V0LCAwXTtcbiAgfSBlbHNlIHtcbiAgICBvZmZzZXRzID0gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXIsIHJlZmVyZW5jZSwgYmFzZVBsYWNlbWVudCk7XG4gIH1cblxuICBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0IC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICd0b3AnKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wIC09IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1sxXTtcbiAgfVxuXG4gIGRhdGEucG9wcGVyID0gcG9wcGVyO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIGJvdW5kYXJpZXNFbGVtZW50ID0gb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCB8fCBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuXG4gIC8vIElmIG9mZnNldFBhcmVudCBpcyB0aGUgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIHJlYWxseSB3YW50IHRvXG4gIC8vIGdvIG9uZSBzdGVwIHVwIGFuZCB1c2UgdGhlIG5leHQgb2Zmc2V0UGFyZW50IGFzIHJlZmVyZW5jZSB0b1xuICAvLyBhdm9pZCB0byBtYWtlIHRoaXMgbW9kaWZpZXIgY29tcGxldGVseSB1c2VsZXNzIGFuZCBsb29rIGxpa2UgYnJva2VuXG4gIGlmIChkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICBib3VuZGFyaWVzRWxlbWVudCA9IGdldE9mZnNldFBhcmVudChib3VuZGFyaWVzRWxlbWVudCk7XG4gIH1cblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzZXRzIHRoZSBwb3BwZXIncyBwb3NpdGlvbiBzbyB0aGF0IHRoZSBkb2N1bWVudCBzaXplIGNhbiBiZSBjYWxjdWxhdGVkIGV4Y2x1ZGluZ1xuICAvLyB0aGUgc2l6ZSBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgaXRzZWxmXG4gIHZhciB0cmFuc2Zvcm1Qcm9wID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcbiAgdmFyIHBvcHBlclN0eWxlcyA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnN0eWxlOyAvLyBhc3NpZ25tZW50IHRvIGhlbHAgbWluaWZpY2F0aW9uXG4gIHZhciB0b3AgPSBwb3BwZXJTdHlsZXMudG9wLFxuICAgICAgbGVmdCA9IHBvcHBlclN0eWxlcy5sZWZ0LFxuICAgICAgdHJhbnNmb3JtID0gcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdO1xuXG4gIHBvcHBlclN0eWxlcy50b3AgPSAnJztcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSAnJztcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gJyc7XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBOT1RFOiBET00gYWNjZXNzIGhlcmVcbiAgLy8gcmVzdG9yZXMgdGhlIG9yaWdpbmFsIHN0eWxlIHByb3BlcnRpZXMgYWZ0ZXIgdGhlIG9mZnNldHMgaGF2ZSBiZWVuIGNvbXB1dGVkXG4gIHBvcHBlclN0eWxlcy50b3AgPSB0b3A7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgcG9wcGVyU3R5bGVzW3RyYW5zZm9ybVByb3BdID0gdHJhbnNmb3JtO1xuXG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdwcmV2ZW50T3ZlcmZsb3cnO1xuICB9KS5ib3VuZGFyaWVzO1xuXG4gIGlmIChyZWZSZWN0LmJvdHRvbSA8IGJvdW5kLnRvcCB8fCByZWZSZWN0LmxlZnQgPiBib3VuZC5yaWdodCB8fCByZWZSZWN0LnRvcCA+IGJvdW5kLmJvdHRvbSB8fCByZWZSZWN0LnJpZ2h0IDwgYm91bmQubGVmdCkge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IHRydWU7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSAnJztcbiAgfSBlbHNlIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gZmFsc2U7XG4gICAgZGF0YS5hdHRyaWJ1dGVzWyd4LW91dC1vZi1ib3VuZGFyaWVzJ10gPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBpbm5lcihkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc0hvcml6ID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIHN1YnRyYWN0TGVuZ3RoID0gWyd0b3AnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPT09IC0xO1xuXG4gIHBvcHBlcltpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCddID0gcmVmZXJlbmNlW2Jhc2VQbGFjZW1lbnRdIC0gKHN1YnRyYWN0TGVuZ3RoID8gcG9wcGVyW2lzSG9yaXogPyAnd2lkdGgnIDogJ2hlaWdodCddIDogMCk7XG5cbiAgZGF0YS5wbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChwb3BwZXIpO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1vZGlmaWVyIGZ1bmN0aW9uLCBlYWNoIG1vZGlmaWVyIGNhbiBoYXZlIGEgZnVuY3Rpb24gb2YgdGhpcyB0eXBlIGFzc2lnbmVkXG4gKiB0byBpdHMgYGZuYCBwcm9wZXJ0eS48YnIgLz5cbiAqIFRoZXNlIGZ1bmN0aW9ucyB3aWxsIGJlIGNhbGxlZCBvbiBlYWNoIHVwZGF0ZSwgdGhpcyBtZWFucyB0aGF0IHlvdSBtdXN0XG4gKiBtYWtlIHN1cmUgdGhleSBhcmUgcGVyZm9ybWFudCBlbm91Z2ggdG8gYXZvaWQgcGVyZm9ybWFuY2UgYm90dGxlbmVja3MuXG4gKlxuICogQGZ1bmN0aW9uIE1vZGlmaWVyRm5cbiAqIEBhcmd1bWVudCB7ZGF0YU9iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5cbi8qKlxuICogTW9kaWZpZXJzIGFyZSBwbHVnaW5zIHVzZWQgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHlvdXIgcG9wcGVycy48YnIgLz5cbiAqIFBvcHBlci5qcyB1c2VzIGEgc2V0IG9mIDkgbW9kaWZpZXJzIHRvIHByb3ZpZGUgYWxsIHRoZSBiYXNpYyBmdW5jdGlvbmFsaXRpZXNcbiAqIG5lZWRlZCBieSB0aGUgbGlicmFyeS5cbiAqXG4gKiBVc3VhbGx5IHlvdSBkb24ndCB3YW50IHRvIG92ZXJyaWRlIHRoZSBgb3JkZXJgLCBgZm5gIGFuZCBgb25Mb2FkYCBwcm9wcy5cbiAqIEFsbCB0aGUgb3RoZXIgcHJvcGVydGllcyBhcmUgY29uZmlndXJhdGlvbnMgdGhhdCBjb3VsZCBiZSB0d2Vha2VkLlxuICogQG5hbWVzcGFjZSBtb2RpZmllcnNcbiAqL1xudmFyIG1vZGlmaWVycyA9IHtcbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gc2hpZnQgdGhlIHBvcHBlciBvbiB0aGUgc3RhcnQgb3IgZW5kIG9mIGl0cyByZWZlcmVuY2VcbiAgICogZWxlbWVudC48YnIgLz5cbiAgICogSXQgd2lsbCByZWFkIHRoZSB2YXJpYXRpb24gb2YgdGhlIGBwbGFjZW1lbnRgIHByb3BlcnR5LjxiciAvPlxuICAgKiBJdCBjYW4gYmUgb25lIGVpdGhlciBgLWVuZGAgb3IgYC1zdGFydGAuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBzaGlmdDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0xMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDEwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHNoaWZ0XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBgb2Zmc2V0YCBtb2RpZmllciBjYW4gc2hpZnQgeW91ciBwb3BwZXIgb24gYm90aCBpdHMgYXhpcy5cbiAgICpcbiAgICogSXQgYWNjZXB0cyB0aGUgZm9sbG93aW5nIHVuaXRzOlxuICAgKiAtIGBweGAgb3IgdW5pdC1sZXNzLCBpbnRlcnByZXRlZCBhcyBwaXhlbHNcbiAgICogLSBgJWAgb3IgYCVyYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgKiAtIGAlcGAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogLSBgdndgLCBDU1Mgdmlld3BvcnQgd2lkdGggdW5pdFxuICAgKiAtIGB2aGAsIENTUyB2aWV3cG9ydCBoZWlnaHQgdW5pdFxuICAgKlxuICAgKiBGb3IgbGVuZ3RoIGlzIGludGVuZGVkIHRoZSBtYWluIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyLjxiciAvPlxuICAgKiBUaGlzIG1lYW5zIHRoYXQgaWYgdGhlIHBsYWNlbWVudCBpcyBgdG9wYCBvciBgYm90dG9tYCwgdGhlIGxlbmd0aCB3aWxsIGJlIHRoZVxuICAgKiBgd2lkdGhgLiBJbiBjYXNlIG9mIGBsZWZ0YCBvciBgcmlnaHRgLCBpdCB3aWxsIGJlIHRoZSBgaGVpZ2h0YC5cbiAgICpcbiAgICogWW91IGNhbiBwcm92aWRlIGEgc2luZ2xlIHZhbHVlIChhcyBgTnVtYmVyYCBvciBgU3RyaW5nYCksIG9yIGEgcGFpciBvZiB2YWx1ZXNcbiAgICogYXMgYFN0cmluZ2AgZGl2aWRlZCBieSBhIGNvbW1hIG9yIG9uZSAob3IgbW9yZSkgd2hpdGUgc3BhY2VzLjxiciAvPlxuICAgKiBUaGUgbGF0dGVyIGlzIGEgZGVwcmVjYXRlZCBtZXRob2QgYmVjYXVzZSBpdCBsZWFkcyB0byBjb25mdXNpb24gYW5kIHdpbGwgYmVcbiAgICogcmVtb3ZlZCBpbiB2Mi48YnIgLz5cbiAgICogQWRkaXRpb25hbGx5LCBpdCBhY2NlcHRzIGFkZGl0aW9ucyBhbmQgc3VidHJhY3Rpb25zIGJldHdlZW4gZGlmZmVyZW50IHVuaXRzLlxuICAgKiBOb3RlIHRoYXQgbXVsdGlwbGljYXRpb25zIGFuZCBkaXZpc2lvbnMgYXJlbid0IHN1cHBvcnRlZC5cbiAgICpcbiAgICogVmFsaWQgZXhhbXBsZXMgYXJlOlxuICAgKiBgYGBcbiAgICogMTBcbiAgICogJzEwJSdcbiAgICogJzEwLCAxMCdcbiAgICogJzEwJSwgMTAnXG4gICAqICcxMCArIDEwJSdcbiAgICogJzEwIC0gNXZoICsgMyUnXG4gICAqICctMTBweCArIDV2aCwgNXB4IC0gNiUnXG4gICAqIGBgYFxuICAgKiA+ICoqTkIqKjogSWYgeW91IGRlc2lyZSB0byBhcHBseSBvZmZzZXRzIHRvIHlvdXIgcG9wcGVycyBpbiBhIHdheSB0aGF0IG1heSBtYWtlIHRoZW0gb3ZlcmxhcFxuICAgKiA+IHdpdGggdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnQsIHVuZm9ydHVuYXRlbHksIHlvdSB3aWxsIGhhdmUgdG8gZGlzYWJsZSB0aGUgYGZsaXBgIG1vZGlmaWVyLlxuICAgKiA+IFlvdSBjYW4gcmVhZCBtb3JlIG9uIHRoaXMgYXQgdGhpcyBbaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgb2Zmc2V0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTIwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogb2Zmc2V0LFxuICAgIC8qKiBAcHJvcCB7TnVtYmVyfFN0cmluZ30gb2Zmc2V0PTBcbiAgICAgKiBUaGUgb2Zmc2V0IHZhbHVlIGFzIGRlc2NyaWJlZCBpbiB0aGUgbW9kaWZpZXIgZGVzY3JpcHRpb25cbiAgICAgKi9cbiAgICBvZmZzZXQ6IDBcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBwcmV2ZW50IHRoZSBwb3BwZXIgZnJvbSBiZWluZyBwb3NpdGlvbmVkIG91dHNpZGUgdGhlIGJvdW5kYXJ5LlxuICAgKlxuICAgKiBBIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIuIFRoaXMgbWFrZXMgc3VyZSB0aGUgcG9wcGVyIGFsd2F5cyBoYXMgYSBsaXR0bGUgcGFkZGluZ1xuICAgICAqIGJldHdlZW4gdGhlIGVkZ2VzIG9mIGl0cyBjb250YWluZXJcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSdzY3JvbGxQYXJlbnQnXG4gICAgICogQm91bmRhcmllcyB1c2VkIGJ5IHRoZSBtb2RpZmllci4gQ2FuIGJlIGBzY3JvbGxQYXJlbnRgLCBgd2luZG93YCxcbiAgICAgKiBgdmlld3BvcnRgIG9yIGFueSBET00gZWxlbWVudC5cbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3Njcm9sbFBhcmVudCdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHN1cmUgdGhlIHJlZmVyZW5jZSBhbmQgaXRzIHBvcHBlciBzdGF5IG5lYXIgZWFjaCBvdGhlclxuICAgKiB3aXRob3V0IGxlYXZpbmcgYW55IGdhcCBiZXR3ZWVuIHRoZSB0d28uIEVzcGVjaWFsbHkgdXNlZnVsIHdoZW4gdGhlIGFycm93IGlzXG4gICAqIGVuYWJsZWQgYW5kIHlvdSB3YW50IHRvIGVuc3VyZSB0aGF0IGl0IHBvaW50cyB0byBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEl0IGNhcmVzIG9ubHkgYWJvdXQgdGhlIGZpcnN0IGF4aXMuIFlvdSBjYW4gc3RpbGwgaGF2ZSBwb3BwZXJzIHdpdGggbWFyZ2luXG4gICAqIGJldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAga2VlcFRvZ2V0aGVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTQwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNDAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjoga2VlcFRvZ2V0aGVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbW9kaWZpZXIgaXMgdXNlZCB0byBtb3ZlIHRoZSBgYXJyb3dFbGVtZW50YCBvZiB0aGUgcG9wcGVyIHRvIG1ha2VcbiAgICogc3VyZSBpdCBpcyBwb3NpdGlvbmVkIGJldHdlZW4gdGhlIHJlZmVyZW5jZSBlbGVtZW50IGFuZCBpdHMgcG9wcGVyIGVsZW1lbnQuXG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgb3V0ZXIgc2l6ZSBvZiB0aGUgYGFycm93RWxlbWVudGAgbm9kZSB0byBkZXRlY3QgaG93IG1hbnlcbiAgICogcGl4ZWxzIG9mIGNvbmp1bmN0aW9uIGFyZSBuZWVkZWQuXG4gICAqXG4gICAqIEl0IGhhcyBubyBlZmZlY3QgaWYgbm8gYGFycm93RWxlbWVudGAgaXMgcHJvdmlkZWQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcnJvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj01MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDUwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFycm93LFxuICAgIC8qKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBlbGVtZW50PSdbeC1hcnJvd10nIC0gU2VsZWN0b3Igb3Igbm9kZSB1c2VkIGFzIGFycm93ICovXG4gICAgZWxlbWVudDogJ1t4LWFycm93XSdcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBmbGlwIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQgd2hlbiBpdCBzdGFydHMgdG8gb3ZlcmxhcCBpdHNcbiAgICogcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICpcbiAgICogKipOT1RFOioqIHRoaXMgbW9kaWZpZXIgd2lsbCBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlIGFuZCB3aWxsXG4gICAqIHJlc3RhcnQgaXQgaWYgaXQgZGV0ZWN0cyB0aGUgbmVlZCB0byBmbGlwIHRoZSBwbGFjZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBmbGlwOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTYwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNjAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogZmxpcCxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEFycmF5fSBiZWhhdmlvcj0nZmxpcCdcbiAgICAgKiBUaGUgYmVoYXZpb3IgdXNlZCB0byBjaGFuZ2UgdGhlIHBvcHBlcidzIHBsYWNlbWVudC4gSXQgY2FuIGJlIG9uZSBvZlxuICAgICAqIGBmbGlwYCwgYGNsb2Nrd2lzZWAsIGBjb3VudGVyY2xvY2t3aXNlYCBvciBhbiBhcnJheSB3aXRoIGEgbGlzdCBvZiB2YWxpZFxuICAgICAqIHBsYWNlbWVudHMgKHdpdGggb3B0aW9uYWwgdmFyaWF0aW9ucylcbiAgICAgKi9cbiAgICBiZWhhdmlvcjogJ2ZsaXAnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBmbGlwIGlmIGl0IGhpdHMgdGhlIGVkZ2VzIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0ndmlld3BvcnQnXG4gICAgICogVGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHBvcHBlciBwb3NpdGlvbi5cbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgbmV2ZXIgYmUgcGxhY2VkIG91dHNpZGUgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllc1xuICAgICAqIChleGNlcHQgaWYgYGtlZXBUb2dldGhlcmAgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0JyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnM9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uczogZmFsc2UsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zQnlDb250ZW50PWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHBvcHBlciBlbGVtZW50IG92ZXJsYXBzIGl0cyByZWZlcmVuY2UgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zQnlDb250ZW50OiBmYWxzZVxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHRydWUsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2JvdHRvbSddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBYIGF4aXMgKGBib3R0b21gIG9yIGB0b3BgKS4gQUtBIFggb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgYm90dG9tYFxuICAgICAqL1xuICAgIHg6ICdib3R0b20nLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdsZWZ0J11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFkgYXhpcyAoYGxlZnRgIG9yIGByaWdodGApLiBBS0EgWSBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGByaWdodGBcbiAgICAgKi9cbiAgICB5OiAncmlnaHQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhlIGNvbXB1dGVkIHN0eWxlcyB0byB0aGUgcG9wcGVyIGVsZW1lbnQuXG4gICAqXG4gICAqIEFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgYXJlIGxpbWl0ZWQgdG8gdGhpcyBtb2RpZmllci4gVGhpcyBpcyB1c2VmdWwgaW4gY2FzZVxuICAgKiB5b3Ugd2FudCB0byBpbnRlZ3JhdGUgUG9wcGVyLmpzIGluc2lkZSBhIGZyYW1ld29yayBvciB2aWV3IGxpYnJhcnkgYW5kIHlvdVxuICAgKiB3YW50IHRvIGRlbGVnYXRlIGFsbCB0aGUgRE9NIG1hbmlwdWxhdGlvbnMgdG8gaXQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpZiB5b3UgZGlzYWJsZSB0aGlzIG1vZGlmaWVyLCB5b3UgbXVzdCBtYWtlIHN1cmUgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIGhhcyBpdHMgcG9zaXRpb24gc2V0IHRvIGBhYnNvbHV0ZWAgYmVmb3JlIFBvcHBlci5qcyBjYW4gZG8gaXRzIHdvcmshXG4gICAqXG4gICAqIEp1c3QgZGlzYWJsZSB0aGlzIG1vZGlmaWVyIGFuZCBkZWZpbmUgeW91ciBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB1bmRlZmluZWRcbiAgfVxufTtcblxuLyoqXG4gKiBUaGUgYGRhdGFPYmplY3RgIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgaW5mb3JtYXRpb24gdXNlZCBieSBQb3BwZXIuanMuXG4gKiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gbW9kaWZpZXJzIGFuZCB0byB0aGUgYG9uQ3JlYXRlYCBhbmQgYG9uVXBkYXRlYCBjYWxsYmFja3MuXG4gKiBAbmFtZSBkYXRhT2JqZWN0XG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5pbnN0YW5jZSBUaGUgUG9wcGVyLmpzIGluc3RhbmNlXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5wbGFjZW1lbnQgUGxhY2VtZW50IGFwcGxpZWQgdG8gcG9wcGVyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCBQbGFjZW1lbnQgb3JpZ2luYWxseSBkZWZpbmVkIG9uIGluaXRcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5mbGlwcGVkIFRydWUgaWYgcG9wcGVyIGhhcyBiZWVuIGZsaXBwZWQgYnkgZmxpcCBtb2RpZmllclxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmhpZGUgVHJ1ZSBpZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0IG9mIGJvdW5kYXJpZXMsIHVzZWZ1bCB0byBrbm93IHdoZW4gdG8gaGlkZSB0aGUgcG9wcGVyXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50c1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5wb3BwZXIgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMuYXJyb3ddIGB0b3BgIGFuZCBgbGVmdGAgb2Zmc2V0cywgb25seSBvbmUgb2YgdGhlbSB3aWxsIGJlIGRpZmZlcmVudCBmcm9tIDBcbiAqL1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucyBwcm92aWRlZCB0byBQb3BwZXIuanMgY29uc3RydWN0b3IuPGJyIC8+XG4gKiBUaGVzZSBjYW4gYmUgb3ZlcnJpZGRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYW4gb2JqZWN0IHdpdGggdGhlIHNhbWVcbiAqIHN0cnVjdHVyZSBvZiB0aGUgYG9wdGlvbnNgIG9iamVjdCwgYXMgdGhlIDNyZCBhcmd1bWVudC4gRm9yIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzID0ge1xuICAvKipcbiAgICogUG9wcGVyJ3MgcGxhY2VtZW50LlxuICAgKiBAcHJvcCB7UG9wcGVyLnBsYWNlbWVudHN9IHBsYWNlbWVudD0nYm90dG9tJ1xuICAgKi9cbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAvKipcbiAgICogU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3Ugd2FudCBwb3BwZXIgdG8gcG9zaXRpb24gaXQgc2VsZiBpbiAnZml4ZWQnIG1vZGVcbiAgICogQHByb3Age0Jvb2xlYW59IHBvc2l0aW9uRml4ZWQ9ZmFsc2VcbiAgICovXG4gIHBvc2l0aW9uRml4ZWQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGV2ZW50cyAocmVzaXplLCBzY3JvbGwpIGFyZSBpbml0aWFsbHkgZW5hYmxlZC5cbiAgICogQHByb3Age0Jvb2xlYW59IGV2ZW50c0VuYWJsZWQ9dHJ1ZVxuICAgKi9cbiAgZXZlbnRzRW5hYmxlZDogdHJ1ZSxcblxuICAvKipcbiAgICogU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuXG4gICAqIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcmVtb3ZlT25EZXN0cm95PWZhbHNlXG4gICAqL1xuICByZW1vdmVPbkRlc3Ryb3k6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIGNyZWF0ZWQuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uQ3JlYXRlfVxuICAgKi9cbiAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgdXBkYXRlZC4gVGhpcyBjYWxsYmFjayBpcyBub3QgY2FsbGVkXG4gICAqIG9uIHRoZSBpbml0aWFsaXphdGlvbi9jcmVhdGlvbiBvZiB0aGUgcG9wcGVyLCBidXQgb25seSBvbiBzdWJzZXF1ZW50XG4gICAqIHVwZGF0ZXMuPGJyIC8+XG4gICAqIEJ5IGRlZmF1bHQsIGl0IGlzIHNldCB0byBuby1vcC48YnIgLz5cbiAgICogQWNjZXNzIFBvcHBlci5qcyBpbnN0YW5jZSB3aXRoIGBkYXRhLmluc3RhbmNlYC5cbiAgICogQHByb3Age29uVXBkYXRlfVxuICAgKi9cbiAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKCkge30sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgbW9kaWZpZXJzIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuXG4gICAqIFRoZXkgcHJvdmlkZSBtb3N0IG9mIHRoZSBmdW5jdGlvbmFsaXRpZXMgb2YgUG9wcGVyLmpzLlxuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IFBvcHBlci5qcyBpbnN0YW5jZS5cbiAgICogQGNsYXNzIFBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR8cmVmZXJlbmNlT2JqZWN0fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgLyBYTUwgZWxlbWVudCB1c2VkIGFzIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBZb3VyIGN1c3RvbSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBvbmVzIGRlZmluZWQgaW4gW0RlZmF1bHRzXSgjZGVmYXVsdHMpXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BwZXIpO1xuXG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMudXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgIHRoaXMudXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIC8vIGluaXQgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgaXNDcmVhdGVkOiBmYWxzZSxcbiAgICAgIHNjcm9sbFBhcmVudHM6IFtdXG4gICAgfTtcblxuICAgIC8vIGdldCByZWZlcmVuY2UgYW5kIHBvcHBlciBlbGVtZW50cyAoYWxsb3cgalF1ZXJ5IHdyYXBwZXJzKVxuICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5qcXVlcnkgPyByZWZlcmVuY2VbMF0gOiByZWZlcmVuY2U7XG4gICAgdGhpcy5wb3BwZXIgPSBwb3BwZXIgJiYgcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgIC8vIERlZXAgbWVyZ2UgbW9kaWZpZXJzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnMsIG9wdGlvbnMubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVyc1tuYW1lXSB8fCB7fSwgb3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdCAoT2JqZWN0ID0+IEFycmF5KVxuICAgIHRoaXMubW9kaWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9LCBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSk7XG4gICAgfSlcbiAgICAvLyBzb3J0IHRoZSBtb2RpZmllcnMgYnkgb3JkZXJcbiAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyT3B0aW9ucykge1xuICAgICAgaWYgKG1vZGlmaWVyT3B0aW9ucy5lbmFibGVkICYmIGlzRnVuY3Rpb24obW9kaWZpZXJPcHRpb25zLm9uTG9hZCkpIHtcbiAgICAgICAgbW9kaWZpZXJPcHRpb25zLm9uTG9hZChfdGhpcy5yZWZlcmVuY2UsIF90aGlzLnBvcHBlciwgX3RoaXMub3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gIH1cblxuICAvLyBXZSBjYW4ndCB1c2UgY2xhc3MgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgZ2V0IGxpc3RlZCBpbiB0aGVcbiAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG5cblxuICBjcmVhdGVDbGFzcyhQb3BwZXIsIFt7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlJCQxKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95JCQxKCkge1xuICAgICAgcmV0dXJuIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGRpc2FibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlcyBhbiB1cGRhdGUuIEl0IHdpbGwgcnVuIG9uIHRoZSBuZXh0IFVJIHVwZGF0ZSBhdmFpbGFibGUuXG4gICAgICogQG1ldGhvZCBzY2hlZHVsZVVwZGF0ZVxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuXG4gICAgLyoqXG4gICAgICogQ29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgdXNlZnVsIHdoZW4gd3JpdGluZyBjdXN0b20gbW9kaWZpZXJzLlxuICAgICAqIFN0YXJ0aW5nIGZyb20gdmVyc2lvbiAxLjcsIHRoaXMgbWV0aG9kIGlzIGF2YWlsYWJsZSBvbmx5IGlmIHlvdVxuICAgICAqIGluY2x1ZGUgYHBvcHBlci11dGlscy5qc2AgYmVmb3JlIGBwb3BwZXIuanNgLlxuICAgICAqXG4gICAgICogKipERVBSRUNBVElPTioqOiBUaGlzIHdheSB0byBhY2Nlc3MgUG9wcGVyVXRpbHMgaXMgZGVwcmVjYXRlZFxuICAgICAqIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjIhIFVzZSB0aGUgUG9wcGVyVXRpbHMgbW9kdWxlIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICogRHVlIHRvIHRoZSBoaWdoIGluc3RhYmlsaXR5IG9mIHRoZSBtZXRob2RzIGNvbnRhaW5lZCBpbiBVdGlscywgd2UgY2FuJ3RcbiAgICAgKiBndWFyYW50ZWUgdGhlbSB0byBmb2xsb3cgc2VtdmVyLiBVc2UgdGhlbSBhdCB5b3VyIG93biByaXNrIVxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjhcbiAgICAgKiBAbWVtYmVyIFV0aWxzXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG4gIH1dKTtcbiAgcmV0dXJuIFBvcHBlcjtcbn0oKTtcblxuLyoqXG4gKiBUaGUgYHJlZmVyZW5jZU9iamVjdGAgaXMgYW4gb2JqZWN0IHRoYXQgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGNvbXBhdGlibGUgd2l0aCBQb3BwZXIuanNcbiAqIGFuZCBsZXRzIHlvdSB1c2UgaXQgYXMgcmVwbGFjZW1lbnQgb2YgYSByZWFsIERPTSBub2RlLjxiciAvPlxuICogWW91IGNhbiB1c2UgdGhpcyBtZXRob2QgdG8gcG9zaXRpb24gYSBwb3BwZXIgcmVsYXRpdmVseSB0byBhIHNldCBvZiBjb29yZGluYXRlc1xuICogaW4gY2FzZSB5b3UgZG9uJ3QgaGF2ZSBhIERPTSBub2RlIHRvIHVzZSBhcyByZWZlcmVuY2UuXG4gKlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZmVyZW5jZU9iamVjdCwgcG9wcGVyTm9kZSk7XG4gKiBgYGBcbiAqXG4gKiBOQjogVGhpcyBmZWF0dXJlIGlzbid0IHN1cHBvcnRlZCBpbiBJbnRlcm5ldCBFeHBsb3JlciAxMC5cbiAqIEBuYW1lIHJlZmVyZW5jZU9iamVjdFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZGF0YS5nZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc2V0IG9mIGNvb3JkaW5hdGVzIGNvbXBhdGlibGUgd2l0aCB0aGUgbmF0aXZlIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgIG1ldGhvZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudFdpZHRoXG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIHdpZHRoIG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50SGVpZ2h0XG4gKiBBbiBFUzYgZ2V0dGVyIHRoYXQgd2lsbCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqL1xuXG5cblBvcHBlci5VdGlscyA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IGdsb2JhbCkuUG9wcGVyVXRpbHM7XG5Qb3BwZXIucGxhY2VtZW50cyA9IHBsYWNlbWVudHM7XG5Qb3BwZXIuRGVmYXVsdHMgPSBEZWZhdWx0cztcblxuZXhwb3J0IGRlZmF1bHQgUG9wcGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cG9wcGVyLmpzLm1hcFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/popper.js/dist/esm/popper.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOlsiZyIsIkZ1bmN0aW9uIiwiZSIsIndpbmRvdyIsIm1vZHVsZSIsImV4cG9ydHMiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxJQUFJQSxDQUFKOztBQUVBO0FBQ0FBLElBQUssWUFBVztBQUNmLFFBQU8sSUFBUDtBQUNBLENBRkcsRUFBSjs7QUFJQSxJQUFJO0FBQ0g7QUFDQUEsS0FBSUEsS0FBSyxJQUFJQyxRQUFKLENBQWEsYUFBYixHQUFUO0FBQ0EsQ0FIRCxDQUdFLE9BQU9DLENBQVAsRUFBVTtBQUNYO0FBQ0EsS0FBSSxRQUFPQyxNQUFQLHlDQUFPQSxNQUFQLE9BQWtCLFFBQXRCLEVBQWdDSCxJQUFJRyxNQUFKO0FBQ2hDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQUMsT0FBT0MsT0FBUCxHQUFpQkwsQ0FBakIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./scss/shiptimize-admin.scss":
/*!************************************!*\
  !*** ./scss/shiptimize-admin.scss ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3NzL3NoaXB0aW1pemUtYWRtaW4uc2Nzcz82MGM5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Ii4vc2Nzcy9zaGlwdGltaXplLWFkbWluLnNjc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./scss/shiptimize-admin.scss\n");

/***/ }),

/***/ "./shiptimize-admin.js":
/*!*****************************!*\
  !*** ./shiptimize-admin.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ./scss/shiptimize-admin.scss */ \"./scss/shiptimize-admin.scss\");\n\nvar _popper = __webpack_require__(/*! popper.js */ \"./node_modules/popper.js/dist/esm/popper.js\");\n\nvar _popper2 = _interopRequireDefault(_popper);\n\nvar _shiptimizeWooCommerceAdmin = __webpack_require__(/*! ./js/shiptimize-woo-commerce-admin.js */ \"./js/shiptimize-woo-commerce-admin.js\");\n\nvar _shiptimizeWooCommerceAdmin2 = _interopRequireDefault(_shiptimizeWooCommerceAdmin);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Shiptimize = function () {\n  function Shiptimize() {\n    _classCallCheck(this, Shiptimize);\n\n    console.log(\"I'm alive!\");\n  }\n\n  /** \n   *  \n   */\n\n\n  _createClass(Shiptimize, [{\n    key: 'bootstrap',\n    value: function bootstrap() {\n      this.tooltips();\n      this.platform = new _shiptimizeWooCommerceAdmin2.default();\n\n      this.loadAnalytics();\n      if (typeof this.platform.bootstrap != 'undefined') {\n        this.platform.bootstrap();\n      }\n    }\n  }, {\n    key: 'tooltips',\n    value: function tooltips() {\n      var toltip = jQuery(\".shiptimize-tooltip-message\");\n      var container = jQuery('#wpcontent');\n\n      if (toltip.size() == 0) {\n        return;\n      }\n\n      var me = this;\n      toltip.each(function (idx, elem) {\n        me.attachPopper(elem, container);\n      });\n    }\n  }, {\n    key: 'attachPopper',\n    value: function attachPopper(toltip, container) {\n      var eToltip = jQuery(toltip);\n      var toltipReference = eToltip.siblings(\".shiptimize-tooltip-reference\");\n      var arrow = eToltip.children('.shiptimize-tooltip-message__arrow').get(0);\n\n      var popper = new _popper2.default(toltipReference.get(0), toltip, {\n        placement: 'left',\n        modifiers: {\n          flip: {\n            behavior: ['top', 'left', 'bottom']\n          },\n          preventOverflow: {\n            boundariesElement: container\n          },\n          offset: {\n            enabled: true,\n            offset: '10,10'\n          },\n          arrow: {\n            enabled: true,\n            element: arrow\n          }\n        }\n      });\n      setTimeout(function () {\n        popper.update();\n      }, 200);\n    }\n  }, {\n    key: 'exportSuccess',\n    value: function exportSuccess(appLink) {\n      this.platform.exportSuccess(appLink);\n    }\n\n    /** \n     * @param string category \n     * @param string action \n     * @param string label \n     */\n\n  }, {\n    key: 'sendAnalyticsEvent',\n    value: function sendAnalyticsEvent(category, action, label) {\n      ga('shiptimize.send', 'event', category, action, label, { transport: 'beacon' });\n    }\n  }, {\n    key: 'loadAnalytics',\n    value: function loadAnalytics() {\n      if (typeof ga == 'undefined') {\n        (function (i, s, o, g, r, a, m) {\n          i['GoogleAnalyticsObject'] = r;\n          i[r] = i[r] || function () {\n            (i[r].q = i[r].q || []).push(arguments);\n          }, i[r].l = 1 * new Date();\n          a = s.createElement(o), m = s.getElementsByTagName(o)[0];\n          a.async = 1;\n          a.src = g;\n          m.parentNode.insertBefore(a, m);\n        })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');\n        console.log(\"inserting analytics \");\n      }\n      ga('create', 'UA-101485643-1', 'auto', 'shiptimize');\n      ga('shiptimize.set', 'anonymizeIp', true);\n      console.log(\"creating tracker\");\n    }\n  }, {\n    key: 'printlabel',\n    value: function printlabel(event, orderid) {\n      var _this = this;\n\n      event.stopPropagation();\n      console.log(\"Printing label for orderid \", orderid);\n\n      var data = {\n        'action': 'shiptimize_print_label',\n        'orderid': orderid\n      };\n\n      this.openLoader(shiptimize_label_request);\n\n      jQuery.post(ajaxurl, data, function (data) {\n        console.log(data);\n\n        if (typeof data.response != 'undefined') {\n          if (typeof data.response.Error != 'undefined' && data.response.Error.Id > 0) {\n            _this.loaderMsg(data.response.Error.Info);\n\n            setTimeout(function () {\n              _this.closeLoader();\n            }, 2000);\n          }\n\n          if (typeof data.response.CallbackURL != 'undefined') {\n            _this.monitorLabelStatus(data.response.CallbackURL);\n          }\n        }\n\n        if (typeof data.errors != 'undefined') {\n          _this.loaderMsg(data.errors.join('<br/>'));\n          setTimeout(function () {\n            _this.closeLoader();\n          }, 5000);\n        }\n      }, \"json\");\n    }\n\n    /**\n     * Request the label status every 1s \n     */\n\n  }, {\n    key: 'monitorLabelStatus',\n    value: function monitorLabelStatus(callbackUrl) {\n      var _this2 = this;\n\n      var data = {\n        'action': 'shiptimize_label_status',\n        'callbackUrl': callbackUrl\n      };\n\n      jQuery.post(ajaxurl, data, function (data) {\n        console.log(data);\n\n        if (typeof data.response != 'undefined') {\n\n          // Check for falta errors \n          if (data.httpCode == '200') {\n            _this2.loaderMsg(shiptimize_label_request + ' ' + data.response.Finished + '%');\n          } else {\n            _this2.loaderMsg(\"Fatal API error \" + data.httpCode);\n            setTimeout(function () {\n              _this2.closeLoader();\n            }, 5000);\n            return;\n          }\n\n          // Print API errors\n          if (data.response.Error.Id > 0) {\n            _this2.loaderMsg(data.response.Error.Info);\n          }\n\n          if (data.response.Error.Id == 902) {\n            //No process running \n            setTimeout(function () {\n              _this2.closeLoader();\n            }, 2000);\n          }\n\n          if (data.response.Finished == 100) {\n            if (data.response.LabelFile.length > 0) {\n              var labelinfo = shiptimize_label_click.replace('%', '<a href=\"' + data.response.LabelFile + '\" target=\\'_blank\\'>' + shiptimize_label_label + '</a>');\n              var noticelist = jQuery(\"#wp__notice-list\");\n              noticelist.removeClass('woocommerce-layout__notice-list-hide');\n              noticelist.append('<div class=\"notice notice-info is-dismissible updated\">' + labelinfo + '</div>');\n              window.open(data.response.LabelFile, '_blank');\n              _this2.closeLoader();\n\n              /** \n               * Make sure the info is updated without the need to reload the page \n               */\n              for (var x = 0; x < data.response.ClientReferenceCodeList.length; ++x) {\n                var labelresult = data.response.ClientReferenceCodeList[x];\n                if (labelresult.Error.Id == 0) {\n                  jQuery(\"#shiptimize-label\" + labelresult.ReferenceCode).addClass('shiptimize-icon-print-printed');\n                } else {\n                  jQuery(\"#shiptimize-label\" + labelresult.ReferenceCode).addClass(\"shiptimize-icon-print-error\");\n                }\n\n                jQuery(\"#shiptimize-tooltip\" + labelresult.ReferenceCode).html(labelresult.message);\n              }\n            } else {\n              var msg = '';\n              for (var x = 0; x < data.response.ClientReferenceCodeList.length; ++x) {\n                var _labelresult = data.response.ClientReferenceCodeList[0];\n                if (_labelresult.Error.Id > 0) {\n                  msg += \"<div class='shiptimize-label-error error'>\" + _labelresult.Error.Info + \"</div>\";\n                }\n                jQuery(\"#shiptimize-label\" + _labelresult.ReferenceCode).addClass(\"shiptimize-icon-print-error\");\n                jQuery(\"#shiptimize-tooltip\" + _labelresult.ReferenceCode).html(_labelresult.message);\n              }\n\n              _this2.loaderMsg(msg);\n              setTimeout(function () {\n                _this2.closeLoader();\n              }, 5000);\n            }\n          }\n\n          if (data.response.Finished < 100) {\n            setTimeout(function () {\n              _this2.monitorLabelStatus(callbackUrl);\n            }, 2000);\n          }\n        }\n      }, \"json\");\n    }\n  }, {\n    key: 'loaderMsg',\n    value: function loaderMsg(message) {\n      jQuery(\".shiptimize-loader-message\").html(message);\n    }\n  }, {\n    key: 'openLoader',\n    value: function openLoader(message) {\n      jQuery('body').append('<div class=\"shiptimize-loader-wrapper\"><div class=\"shiptimize-loader\"><div></div><div></div><div></div></div><div class=\"shiptimize-loader-message\">' + message + '</div></div>');\n    }\n  }, {\n    key: 'closeLoader',\n    value: function closeLoader() {\n      jQuery(\".shiptimize-loader-wrapper\").remove();\n    }\n  }]);\n\n  return Shiptimize;\n}();\n\njQuery(function () {\n  window.shiptimize = new Shiptimize();\n  window.shiptimize.bootstrap();\n  window.Popper = _popper2.default;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zaGlwdGltaXplLWFkbWluLmpzPzM4YTIiXSwibmFtZXMiOlsiU2hpcHRpbWl6ZSIsImNvbnNvbGUiLCJsb2ciLCJ0b29sdGlwcyIsInBsYXRmb3JtIiwiV29vU2hpcHRpbWl6ZSIsImxvYWRBbmFseXRpY3MiLCJib290c3RyYXAiLCJ0b2x0aXAiLCJqUXVlcnkiLCJjb250YWluZXIiLCJzaXplIiwibWUiLCJlYWNoIiwiaWR4IiwiZWxlbSIsImF0dGFjaFBvcHBlciIsImVUb2x0aXAiLCJ0b2x0aXBSZWZlcmVuY2UiLCJzaWJsaW5ncyIsImFycm93IiwiY2hpbGRyZW4iLCJnZXQiLCJwb3BwZXIiLCJQb3BwZXIiLCJwbGFjZW1lbnQiLCJtb2RpZmllcnMiLCJmbGlwIiwiYmVoYXZpb3IiLCJwcmV2ZW50T3ZlcmZsb3ciLCJib3VuZGFyaWVzRWxlbWVudCIsIm9mZnNldCIsImVuYWJsZWQiLCJlbGVtZW50Iiwic2V0VGltZW91dCIsInVwZGF0ZSIsImFwcExpbmsiLCJleHBvcnRTdWNjZXNzIiwiY2F0ZWdvcnkiLCJhY3Rpb24iLCJsYWJlbCIsImdhIiwidHJhbnNwb3J0IiwiaSIsInMiLCJvIiwiZyIsInIiLCJhIiwibSIsInEiLCJwdXNoIiwiYXJndW1lbnRzIiwibCIsIkRhdGUiLCJjcmVhdGVFbGVtZW50IiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJhc3luYyIsInNyYyIsInBhcmVudE5vZGUiLCJpbnNlcnRCZWZvcmUiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImV2ZW50Iiwib3JkZXJpZCIsInN0b3BQcm9wYWdhdGlvbiIsImRhdGEiLCJvcGVuTG9hZGVyIiwic2hpcHRpbWl6ZV9sYWJlbF9yZXF1ZXN0IiwicG9zdCIsImFqYXh1cmwiLCJyZXNwb25zZSIsIkVycm9yIiwiSWQiLCJsb2FkZXJNc2ciLCJJbmZvIiwiY2xvc2VMb2FkZXIiLCJDYWxsYmFja1VSTCIsIm1vbml0b3JMYWJlbFN0YXR1cyIsImVycm9ycyIsImpvaW4iLCJjYWxsYmFja1VybCIsImh0dHBDb2RlIiwiRmluaXNoZWQiLCJMYWJlbEZpbGUiLCJsZW5ndGgiLCJsYWJlbGluZm8iLCJzaGlwdGltaXplX2xhYmVsX2NsaWNrIiwicmVwbGFjZSIsInNoaXB0aW1pemVfbGFiZWxfbGFiZWwiLCJub3RpY2VsaXN0IiwicmVtb3ZlQ2xhc3MiLCJhcHBlbmQiLCJvcGVuIiwieCIsIkNsaWVudFJlZmVyZW5jZUNvZGVMaXN0IiwibGFiZWxyZXN1bHQiLCJSZWZlcmVuY2VDb2RlIiwiYWRkQ2xhc3MiLCJodG1sIiwibWVzc2FnZSIsIm1zZyIsInJlbW92ZSIsInNoaXB0aW1pemUiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFDQTs7OztBQUVBOzs7Ozs7OztJQUVNQSxVO0FBRUosd0JBQWE7QUFBQTs7QUFDWEMsWUFBUUMsR0FBUixDQUFZLFlBQVo7QUFDRDs7QUFFRDs7Ozs7OztnQ0FHVztBQUNULFdBQUtDLFFBQUw7QUFDQSxXQUFLQyxRQUFMLEdBQWdCLElBQUlDLG9DQUFKLEVBQWhCOztBQUVBLFdBQUtDLGFBQUw7QUFDQSxVQUFHLE9BQU8sS0FBS0YsUUFBTCxDQUFjRyxTQUFyQixJQUFtQyxXQUF0QyxFQUFtRDtBQUNqRCxhQUFLSCxRQUFMLENBQWNHLFNBQWQ7QUFDRDtBQUNGOzs7K0JBRVU7QUFDVCxVQUFJQyxTQUFTQyxPQUFPLDZCQUFQLENBQWI7QUFDQSxVQUFJQyxZQUFZRCxPQUFPLFlBQVAsQ0FBaEI7O0FBRUEsVUFBS0QsT0FBT0csSUFBUCxNQUFpQixDQUF0QixFQUEwQjtBQUN4QjtBQUNEOztBQUVELFVBQUlDLEtBQUssSUFBVDtBQUNBSixhQUFPSyxJQUFQLENBQWEsVUFBV0MsR0FBWCxFQUFnQkMsSUFBaEIsRUFBdUI7QUFDbENILFdBQUdJLFlBQUgsQ0FBZ0JELElBQWhCLEVBQXFCTCxTQUFyQjtBQUNELE9BRkQ7QUFJRDs7O2lDQUVZRixNLEVBQVFFLFMsRUFBVTtBQUM3QixVQUFJTyxVQUFVUixPQUFPRCxNQUFQLENBQWQ7QUFDQSxVQUFJ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QWY7QUFDQW5FLHlCQUFXLFlBQU07QUFBRSx1QkFBSzBDLFdBQUw7QUFBcUIsZUFBeEMsRUFBMEMsSUFBMUM7QUFDRDtBQUNGOztBQUVELGNBQUdWLEtBQUtLLFFBQUwsQ0FBY1ksUUFBZCxHQUF5QixHQUE1QixFQUFpQztBQUMvQmpELHVCQUFZLFlBQU07QUFBRSxxQkFBSzRDLGtCQUFMLENBQXdCRyxXQUF4QjtBQUF1QyxhQUEzRCxFQUE2RCxJQUE3RDtBQUNEO0FBQ0Y7QUFFRixPQXZFRCxFQXVFRyxNQXZFSDtBQXdFRDs7OzhCQUVTbUIsTyxFQUFTO0FBQ2pCM0YsYUFBTyw0QkFBUCxFQUFxQzBGLElBQXJDLENBQTBDQyxPQUExQztBQUNEOzs7K0JBRVVBLE8sRUFBUztBQUNsQjNGLGFBQU8sTUFBUCxFQUFlbUYsTUFBZixDQUFzQix5SkFBeUpRLE9BQXpKLEdBQW9LLGNBQTFMO0FBQ0Q7OztrQ0FFWTtBQUNYM0YsYUFBTyw0QkFBUCxFQUFxQzZGLE1BQXJDO0FBQ0Q7Ozs7OztBQUdIN0YsT0FBTyxZQUFZO0FBQ2pCb0QsU0FBTzBDLFVBQVAsR0FBb0IsSUFBSXZHLFVBQUosRUFBcEI7QUFDQTZELFNBQU8wQyxVQUFQLENBQWtCaEcsU0FBbEI7QUFDQXNELFNBQU9yQyxNQUFQLEdBQWdCQSxnQkFBaEI7QUFDRCxDQUpEIiwiZmlsZSI6Ii4vc2hpcHRpbWl6ZS1hZG1pbi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnLi9zY3NzL3NoaXB0aW1pemUtYWRtaW4uc2Nzcyc7XG5pbXBvcnQgUG9wcGVyIGZyb20gJ3BvcHBlci5qcyc7IFxuXG5pbXBvcnQgV29vU2hpcHRpbWl6ZSAgZnJvbSAnLi9qcy9zaGlwdGltaXplLXdvby1jb21tZXJjZS1hZG1pbi5qcyc7IFxuXG5jbGFzcyBTaGlwdGltaXplIHtcblxuICBjb25zdHJ1Y3Rvcigpe1xuICAgIGNvbnNvbGUubG9nKFwiSSdtIGFsaXZlIVwiKTsgXG4gIH1cblxuICAvKiogXG4gICAqICBcbiAgICovIFxuICBib290c3RyYXAoKXtcbiAgICB0aGlzLnRvb2x0aXBzKCk7IFxuICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgV29vU2hpcHRpbWl6ZSgpOyBcblxuICAgIHRoaXMubG9hZEFuYWx5dGljcygpOyBcbiAgICBpZih0eXBlb2YodGhpcy5wbGF0Zm9ybS5ib290c3RyYXApICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLnBsYXRmb3JtLmJvb3RzdHJhcCgpO1xuICAgIH1cbiAgfVxuXG4gIHRvb2x0aXBzKCApe1xuICAgIGxldCB0b2x0aXAgPSBqUXVlcnkoXCIuc2hpcHRpbWl6ZS10b29sdGlwLW1lc3NhZ2VcIik7XG4gICAgbGV0IGNvbnRhaW5lciA9IGpRdWVyeSgnI3dwY29udGVudCcpOyBcblxuICAgIGlmICggdG9sdGlwLnNpemUoKSA9PSAwICkge1xuICAgICAgcmV0dXJuOyBcbiAgICB9XG5cbiAgICBsZXQgbWUgPSB0aGlzOyBcbiAgICB0b2x0aXAuZWFjaCggZnVuY3Rpb24gKCBpZHgsIGVsZW0gKSB7XG4gICAgICBtZS5hdHRhY2hQb3BwZXIoZWxlbSxjb250YWluZXIpO1xuICAgIH0pOyAgICAgIFxuXG4gIH1cblxuICBhdHRhY2hQb3BwZXIodG9sdGlwLCBjb250YWluZXIpeyAgXG4gICAgbGV0IGVUb2x0aXAgPSBqUXVlcnkodG9sdGlwKTsgXG4gICAgbGV0IHRvbHRpcFJlZmVyZW5jZSA9IGVUb2x0aXAuc2libGluZ3MoXCIuc2hpcHRpbWl6ZS10b29sdGlwLXJlZmVyZW5jZVwiKTtcbiAgICBsZXQgYXJyb3cgPSBlVG9sdGlwLmNoaWxkcmVuKCcuc2hpcHRpbWl6ZS10b29sdGlwLW1lc3NhZ2VfX2Fycm93JykuZ2V0KDApOyBcblxuICAgIHZhciBwb3BwZXIgPSBuZXcgUG9wcGVyKHRvbHRpcFJlZmVyZW5jZS5nZXQoMCksIHRvbHRpcCwge1xuICAgICAgcGxhY2VtZW50OiAnbGVmdCcsXG4gICAgICBtb2RpZmllcnM6IHtcbiAgICAgICAgICBmbGlwOiB7XG4gICAgICAgICAgICAgIGJlaGF2aW9yOiBbJ3RvcCcsJ2xlZnQnLCAnYm90dG9tJ11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZXZlbnRPdmVyZmxvdzoge1xuICAgICAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogY29udGFpbmVyLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb2Zmc2V0OiB7IFxuICAgICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgICBvZmZzZXQ6ICcxMCwxMCdcbiAgICAgICAgICB9LFxuICAgICAgICAgIGFycm93OiB7XG4gICAgICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICAgICAgZWxlbWVudDogYXJyb3dcbiAgICAgICAgICB9XG4gICAgICB9LCBcbiAgICB9KTsgIFxuICAgIHNldFRpbWVvdXQgKCAoKSA9PiB7IHBvcHBlci51cGRhdGUoKTsgfSAsIDIwMCk7ICAgICBcbiAgfVxuXG4gIGV4cG9ydFN1Y2Nlc3MoYXBwTGluayl7XG4gICAgdGhpcy5wbGF0Zm9ybS5leHBvcnRTdWNjZXNzKGFwcExpbmspO1xuICB9XG5cbiAgLyoqIFxuICAgKiBAcGFyYW0gc3RyaW5nIGNhdGVnb3J5IFxuICAgKiBAcGFyYW0gc3RyaW5nIGFjdGlvbiBcbiAgICogQHBhcmFtIHN0cmluZyBsYWJlbCBcbiAgICovXG4gIHNlbmRBbmFseXRpY3NFdmVudChjYXRlZ29yeSwgYWN0aW9uLCBsYWJlbCkge1xuICAgICAgZ2EoJ3NoaXB0aW1pemUuc2VuZCcsICdldmVudCcsIGNhdGVnb3J5LCBhY3Rpb24sIGxhYmVsLCB7IHRyYW5zcG9ydDogJ2JlYWNvbicgfSk7XG4gIH1cblxuICBsb2FkQW5hbHl0aWNzKCkge1xuICAgICAgaWYgKHR5cGVvZihnYSkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAoZnVuY3Rpb24oaSwgcywgbywgZywgciwgYSwgbSkge1xuICAgICAgICAgICAgICBpWydHb29nbGVBbmFseXRpY3NPYmplY3QnXSA9IHI7XG4gICAgICAgICAgICAgIGlbcl0gPSBpW3JdIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgKGlbcl0ucSA9IGlbcl0ucSB8fCBbXSkucHVzaChhcmd1bWVudHMpXG4gICAgICAgICAgICAgIH0sIGlbcl0ubCA9IDEgKiBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgICBhID0gcy5jcmVhdGVFbGVtZW50KG8pLFxuICAgICAgICAgICAgICAgICAgbSA9IHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUobylbMF07XG4gICAgICAgICAgICAgIGEuYXN5bmMgPSAxO1xuICAgICAgICAgICAgICBhLnNyYyA9IGc7XG4gICAgICAgICAgICAgIG0ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYSwgbSlcbiAgICAgICAgICB9KSh3aW5kb3csIGRvY3VtZW50LCAnc2NyaXB0JywgJ2h0dHBzOi8vd3d3Lmdvb2dsZS1hbmFseXRpY3MuY29tL2FuYWx5dGljcy5qcycsICdnYScpO1xuICAgICAgICAgIGNvbnNvbGUubG9nKFwiaW5zZXJ0aW5nIGFuYWx5dGljcyBcIik7XG4gICAgICB9IFxuICAgICAgZ2EoJ2NyZWF0ZScsICdVQS0xMDE0ODU2NDMtMScsICdhdXRvJywgJ3NoaXB0aW1pemUnKTtcbiAgICAgIGdhKCdzaGlwdGltaXplLnNldCcsICdhbm9ueW1pemVJcCcsIHRydWUpO1xuICAgICAgY29uc29sZS5sb2coXCJjcmVhdGluZyB0cmFja2VyXCIpO1xuICB9XG5cbiAgcHJpbnRsYWJlbChldmVudCwgb3JkZXJpZCkge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyBcbiAgICBjb25zb2xlLmxvZyAoXCJQcmludGluZyBsYWJlbCBmb3Igb3JkZXJpZCBcIiwgb3JkZXJpZCk7XG5cbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICdhY3Rpb24nOiAnc2hpcHRpbWl6ZV9wcmludF9sYWJlbCcsIFxuICAgICAgJ29yZGVyaWQnOiBvcmRlcmlkXG4gICAgfTsgXG5cbiAgICB0aGlzLm9wZW5Mb2FkZXIoc2hpcHRpbWl6ZV9sYWJlbF9yZXF1ZXN0KTsgXG5cbiAgICBqUXVlcnkucG9zdChhamF4dXJsLCBkYXRhLCAoZGF0YSkgPT4ge1xuICAgICAgY29uc29sZS5sb2coZGF0YSk7IFxuXG4gICAgICBpZiAodHlwZW9mKGRhdGEucmVzcG9uc2UpICE9ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgIGlmKHR5cGVvZihkYXRhLnJlc3BvbnNlLkVycm9yKSAhPSAndW5kZWZpbmVkJyAmJiBkYXRhLnJlc3BvbnNlLkVycm9yLklkID4gMCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkZXJNc2coZGF0YS5yZXNwb25zZS5FcnJvci5JbmZvKTtcblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuY2xvc2VMb2FkZXIoKTsgfSwgMjAwMCk7ICBcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZih0eXBlb2YoZGF0YS5yZXNwb25zZS5DYWxsYmFja1VSTCkgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMubW9uaXRvckxhYmVsU3RhdHVzKGRhdGEucmVzcG9uc2UuQ2FsbGJhY2tVUkwpOyAgICAgICAgICAgICBcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmKHR5cGVvZihkYXRhLmVycm9ycykgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5sb2FkZXJNc2coZGF0YS5lcnJvcnMuam9pbignPGJyLz4nKSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmNsb3NlTG9hZGVyKCk7IH0sIDUwMDApOyAgXG4gICAgICB9XG4gICAgfSwgXCJqc29uXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3QgdGhlIGxhYmVsIHN0YXR1cyBldmVyeSAxcyBcbiAgICovXG4gIG1vbml0b3JMYWJlbFN0YXR1cyhjYWxsYmFja1VybCkge1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgJ2FjdGlvbic6ICdzaGlwdGltaXplX2xhYmVsX3N0YXR1cycsXG4gICAgICAnY2FsbGJhY2tVcmwnOiBjYWxsYmFja1VybFxuICAgIH07IFxuXG4gICAgalF1ZXJ5LnBvc3QoYWpheHVybCwgZGF0YSwgKGRhdGEpID0+IHtcbiAgICAgIGNvbnNvbGUubG9nKGRhdGEpOyBcblxuICAgICAgaWYodHlwZW9mKGRhdGEucmVzcG9uc2UpIT0gJ3VuZGVmaW5lZCcpIHtcblxuICAgICAgICAvLyBDaGVjayBmb3IgZmFsdGEgZXJyb3JzIFxuICAgICAgICBpZihkYXRhLmh0dHBDb2RlID09ICcyMDAnKSB7XG4gICAgICAgICAgdGhpcy5sb2FkZXJNc2coc2hpcHRpbWl6ZV9sYWJlbF9yZXF1ZXN0ICsgJyAnICsgZGF0YS5yZXNwb25zZS5GaW5pc2hlZCArICclJyk7ICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2FkZXJNc2coXCJGYXRhbCBBUEkgZXJyb3IgXCIgKyBkYXRhLmh0dHBDb2RlKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhpcy5jbG9zZUxvYWRlcigpOyB9LCA1MDAwKTtcbiAgICAgICAgICByZXR1cm47IFxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUHJpbnQgQVBJIGVycm9yc1xuICAgICAgICBpZiAoZGF0YS5yZXNwb25zZS5FcnJvci5JZCA+IDApIHtcbiAgICAgICAgICB0aGlzLmxvYWRlck1zZyhkYXRhLnJlc3BvbnNlLkVycm9yLkluZm8pOyBcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGRhdGEucmVzcG9uc2UuRXJyb3IuSWQgPT0gOTAyKSB7IC8vTm8gcHJvY2VzcyBydW5uaW5nIFxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICB0aGlzLmNsb3NlTG9hZGVyKClcbiAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKGRhdGEucmVzcG9uc2UuRmluaXNoZWQgPT0gMTAwICkge1xuICAgICAgICAgIGlmICggZGF0YS5yZXNwb25zZS5MYWJlbEZpbGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgbGV0IGxhYmVsaW5mbyA9IHNoaXB0aW1pemVfbGFiZWxfY2xpY2sucmVwbGFjZSgnJScsYDxhIGhyZWY9XCIke2RhdGEucmVzcG9uc2UuTGFiZWxGaWxlfVwiIHRhcmdldD0nX2JsYW5rJz4ke3NoaXB0aW1pemVfbGFiZWxfbGFiZWx9PC9hPmApO1xuICAgICAgICAgICAgbGV0IG5vdGljZWxpc3QgPSBqUXVlcnkoXCIjd3BfX25vdGljZS1saXN0XCIpOyBcbiAgICAgICAgICAgIG5vdGljZWxpc3QucmVtb3ZlQ2xhc3MoJ3dvb2NvbW1lcmNlLWxheW91dF9fbm90aWNlLWxpc3QtaGlkZScpOyBcbiAgICAgICAgICAgIG5vdGljZWxpc3QuYXBwZW5kKGA8ZGl2IGNsYXNzPVwibm90aWNlIG5vdGljZS1pbmZvIGlzLWRpc21pc3NpYmxlIHVwZGF0ZWRcIj4ke2xhYmVsaW5mb308L2Rpdj5gKTtcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKGRhdGEucmVzcG9uc2UuTGFiZWxGaWxlLCdfYmxhbmsnKTsgXG4gICAgICAgICAgICB0aGlzLmNsb3NlTG9hZGVyKCk7XG5cbiAgICAgICAgICAgIC8qKiBcbiAgICAgICAgICAgICAqIE1ha2Ugc3VyZSB0aGUgaW5mbyBpcyB1cGRhdGVkIHdpdGhvdXQgdGhlIG5lZWQgdG8gcmVsb2FkIHRoZSBwYWdlIFxuICAgICAgICAgICAgICovIFxuICAgICAgICAgICAgZm9yKHZhciB4ID0wOyB4IDwgZGF0YS5yZXNwb25zZS5DbGllbnRSZWZlcmVuY2VDb2RlTGlzdC5sZW5ndGg7ICsreCkge1xuICAgICAgICAgICAgICB2YXIgbGFiZWxyZXN1bHQgPSBkYXRhLnJlc3BvbnNlLkNsaWVudFJlZmVyZW5jZUNvZGVMaXN0W3hdOyBcbiAgICAgICAgICAgICAgaWYobGFiZWxyZXN1bHQuRXJyb3IuSWQgPT0gMCkgeyBcbiAgICAgICAgICAgICAgICBqUXVlcnkoXCIjc2hpcHRpbWl6ZS1sYWJlbFwiICsgbGFiZWxyZXN1bHQuUmVmZXJlbmNlQ29kZSkuYWRkQ2xhc3MoJ3NoaXB0aW1pemUtaWNvbi1wcmludC1wcmludGVkJyk7ICAgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5KFwiI3NoaXB0aW1pemUtbGFiZWxcIiArIGxhYmVscmVzdWx0LlJlZmVyZW5jZUNvZGUpLmFkZENsYXNzKFwic2hpcHRpbWl6ZS1pY29uLXByaW50LWVycm9yXCIpOyAgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIGpRdWVyeShcIiNzaGlwdGltaXplLXRvb2x0aXBcIiArIGxhYmVscmVzdWx0LlJlZmVyZW5jZUNvZGUpLmh0bWwobGFiZWxyZXN1bHQubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1zZyA9ICcnOyBcbiAgICAgICAgICAgIGZvciAoIHZhciB4PTA7IHggPCBkYXRhLnJlc3BvbnNlLkNsaWVudFJlZmVyZW5jZUNvZGVMaXN0Lmxlbmd0aDsgKyt4ICkge1xuICAgICAgICAgICAgICBsZXQgbGFiZWxyZXN1bHQgPSBkYXRhLnJlc3BvbnNlLkNsaWVudFJlZmVyZW5jZUNvZGVMaXN0WzBdOyBcbiAgICAgICAgICAgICAgaWYobGFiZWxyZXN1bHQuRXJyb3IuSWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgbXNnICs9IFwiPGRpdiBjbGFzcz0nc2hpcHRpbWl6ZS1sYWJlbC1lcnJvciBlcnJvcic+XCIgKyBsYWJlbHJlc3VsdC5FcnJvci5JbmZvICsgXCI8L2Rpdj5cIjsgXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgalF1ZXJ5KFwiI3NoaXB0aW1pemUtbGFiZWxcIiArIGxhYmVscmVzdWx0LlJlZmVyZW5jZUNvZGUpLmFkZENsYXNzKFwic2hpcHRpbWl6ZS1pY29uLXByaW50LWVycm9yXCIpOyAgXG4gICAgICAgICAgICAgIGpRdWVyeShcIiNzaGlwdGltaXplLXRvb2x0aXBcIiArIGxhYmVscmVzdWx0LlJlZmVyZW5jZUNvZGUpLmh0bWwobGFiZWxyZXN1bHQubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubG9hZGVyTXNnKG1zZyk7IFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRoaXMuY2xvc2VMb2FkZXIoKTsgfSwgNTAwMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYoZGF0YS5yZXNwb25zZS5GaW5pc2hlZCA8IDEwMCkge1xuICAgICAgICAgIHNldFRpbWVvdXQoICgpID0+IHsgdGhpcy5tb25pdG9yTGFiZWxTdGF0dXMoY2FsbGJhY2tVcmwpOyB9LCAyMDAwKTsgXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0sIFwianNvblwiKTtcbiAgfVxuXG4gIGxvYWRlck1zZyhtZXNzYWdlKSB7XG4gICAgalF1ZXJ5KFwiLnNoaXB0aW1pemUtbG9hZGVyLW1lc3NhZ2VcIikuaHRtbChtZXNzYWdlKTsgXG4gIH1cblxuICBvcGVuTG9hZGVyKG1lc3NhZ2UpIHtcbiAgICBqUXVlcnkoJ2JvZHknKS5hcHBlbmQoJzxkaXYgY2xhc3M9XCJzaGlwdGltaXplLWxvYWRlci13cmFwcGVyXCI+PGRpdiBjbGFzcz1cInNoaXB0aW1pemUtbG9hZGVyXCI+PGRpdj48L2Rpdj48ZGl2PjwvZGl2PjxkaXY+PC9kaXY+PC9kaXY+PGRpdiBjbGFzcz1cInNoaXB0aW1pemUtbG9hZGVyLW1lc3NhZ2VcIj4nICsgbWVzc2FnZSAgKyAnPC9kaXY+PC9kaXY+Jyk7IFxuICB9XG5cbiAgY2xvc2VMb2FkZXIoKXtcbiAgICBqUXVlcnkoXCIuc2hpcHRpbWl6ZS1sb2FkZXItd3JhcHBlclwiKS5yZW1vdmUoKTsgXG4gIH1cbn1cblxualF1ZXJ5KGZ1bmN0aW9uICgpIHtcbiAgd2luZG93LnNoaXB0aW1pemUgPSBuZXcgU2hpcHRpbWl6ZSgpO1xuICB3aW5kb3cuc2hpcHRpbWl6ZS5ib290c3RyYXAoKTsgXG4gIHdpbmRvdy5Qb3BwZXIgPSBQb3BwZXI7XG59KTtcblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./shiptimize-admin.js\n");

/***/ })

/******/ });